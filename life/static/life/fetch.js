import {iucnRedList, months, imageFileTypes, countryCodes} from './officialDesignations.js';
import {displayImages} from './image.js';
import search from './search.js';
import {fadeIn, fadeTime} from './animation.js';

export default function fetchEverything(GBIFResult, y)
{
	const keyID = GBIFResult[taxaKeys[y]].keyID;
	const theInfo = GBIFResult[taxaKeys[y]].info;
	const theColor = GBIFResult[taxaKeys[y]].color;
	
	var localDjangoDB = false;
	if (GBIFResult[taxaKeys[y]].localDjangoDB !== undefined) localDjangoDB = true; // the species only
	if (localDjangoDB) console.log('+ + + L O C A L + + +');
	const allSuperElements = [];
	
 	let childrenLoaded = false; 	let synonymsLoaded = false; let distributionsLoaded = false; let vernacularNamesLoaded = false;
	
	// ID fetch delivers a "proper" json object for the rank object. Most likely, the object content is identical to the content of the responded object from a user query (vernacular or scientific name). (See the first object visible in the console when doing a query, generated by the first console.log in checkResponse(), then compare it to the console message ("ID SEARCH") when clicking on the rank object, as generated by this fetch).
	// Once the rank object is found by query, all further fetches regarding this rank object are done over the ID.
	// IMPORTANT HINT: as you can see in the fetches, they all address 'species' objects, which is the standard address for any singular GBIF entity of ANY rank, not just species from the taxonomy rank SPECIES. To avoid confusion, I call them "rank objects" (most of the time) in my comments, to make clear that they entail GENUS, FAMILY...
	fetch(((localDjangoDB) ? '/life/species/' : 'https://api.gbif.org/v1/species/')+keyID)
	.then(response => response.json())
	.then(incoming =>{console.log('ID SEARCH: '); console.log(incoming)})
	
	fetch('https://api.gbif.org/v1/species/'+keyID+'/children?limit=500')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('CHILDREN: ');
		console.log(incoming.results); //console.log(incoming);
		if (y < 6 && incoming.results.length !== 0) // there are in fact sometimes GENERA, FAMILIES etc. that don't have children; it's the rarer case, but it exists. 
		{
			const children = g();
			let childCount = 0;
			for (const child of incoming.results)
			{/*
				if (y+2 < 7)
				{
					if (child.rank.toLowerCase() === taxaKeys[y+2]) break; // prevents moving over to grandchildren if direct children are exhausted. UPDATE: doesn't quite work, apparently the array is not always sorted from highest rank downwards.
				}*/
				// if (child.rank === 'UNRANKED') continue;
				if (child.rank.toLowerCase() === taxaKeys[y+1])
				{
					const thisChild = g();
					thisChild.innerHTML = "<strong>"+ child.rank.toUpperCase()+"</strong> "+child.canonicalName+"<br>";
					const theChild = child.key;
					thisChild.onclick = ()=> {console.log('SEARCHING FOR CHILD ID: '+theChild); search(theChild)}
					thisChild.style.cursor = 'pointer';
					thisChild.style["margin-right"] = "15px";
					children.append(thisChild);
					childCount++;
				}
			}
			const superElement = g();
			superElement.classList.add('baseBlock');
			
			superElement.style['background-color'] = `hsl(${theColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			const elementTitle = g();
			elementTitle.innerHTML = '<strong>CHILDREN</strong>';
			superElement.append(elementTitle);
			if (childCount > 5)
			{
				superElement.style.height = "220px";
				children.style.height = "150px";
				children.style["overflow-y"] = "auto";
			}
			superElement.append(children);
			theInfo.append(superElement);
			superElement.animate(fadeIn, fadeTime);
			allSuperElements.push(superElement);
			if (superElement.getBoundingClientRect().width > 600 && !isMobile) superElement.style.width = '600px';
		}
		childrenLoaded = true;
	})
	
	fetch((localDjangoDB) ? '/life/species/'+keyID+'/synonyms?limit=500' : 'https://api.gbif.org/v1/species/'+keyID+'/synonyms?limit=500')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('SYNONYMS: ');
		console.log(incoming)
		const allSynonyms = g(); 
		if (incoming.results.length !== 0)
		{
			let synonymsCount = 0;
			let checkDuplicates ="";
			for (const synonym of incoming.results)
			{
				if (checkDuplicates.indexOf(synonym.canonicalName) !== -1) continue;
				const theSynonym = g();
				theSynonym.innerHTML = synonym.canonicalName;
				allSynonyms.append(theSynonym);
				checkDuplicates += synonym.canonicalName;
				synonymsCount++;
			}
			const superElement = g();
			superElement.classList.add('baseBlock');
					
			superElement.style['background-color'] = `hsl(${theColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			const elementTitle = g();
			elementTitle.innerHTML = '<strong>SYNONYMS</strong>';
			superElement.append(elementTitle);
			if (synonymsCount > 5)
			{
				superElement.style.height = "220px";
				allSynonyms.style.height = "150px";
				allSynonyms.style["overflow-y"] = "auto";
			}
			superElement.append(allSynonyms);
			theInfo.append(superElement);
			superElement.animate(fadeIn, fadeTime);
			allSuperElements.push(superElement);
			if (superElement.getBoundingClientRect().width > 600 && !isMobile) superElement.style.width = '600px';
		}
		synonymsLoaded = true;
	})
	
	fetch((localDjangoDB) ? '/life/species/'+keyID+'/descriptions' : 'https://api.gbif.org/v1/species/'+keyID+'/descriptions')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('DESCRIPTIONS: ');
		console.log(incoming);
		const allDescriptions = g(); 
		if (incoming.results.length !== 0)
		{
			for (const description of incoming.results)
			{
				if (description.description.indexOf("There is no information available for this species.") !== -1) continue; // There may still be descriptions that start with "There is no information available for this species, but / other than...", so the comma ',' would save it from getting kicked out.
				const theDescription = g();
				theDescription.innerHTML = "<strong>"+ description.type.toUpperCase().replace("_"," ")+"</strong><br>"+description.description+"<br><br>";
				allDescriptions.append(theDescription);
			}
			const superElement = g();
			superElement.classList.add('baseBlock');
			superElement.style['background-color'] = `hsl(${theColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			//const elementTitle = g();
			//elementTitle.innerHTML = '<strong>DESCRIPTIONS</strong>';
			superElement.append(/*elementTitle,*/ allDescriptions);
			
			const resizeObserver = new ResizeObserver((entries) =>
			{
				allDescriptions.style.height = entries[0].contentRect.height-40+"px";
				for (const element of allSuperElements)
				{
					element.style.width = entries[0].contentRect.width+40+'px';
				}
			});
			
			checkOtherElementsLoaded();
			function checkOtherElementsLoaded() // makes certain that the 'DESCRIPTION' element comes last within the description part (clicking on a GBIF rank object). Reason being that the desciption element is the only one you can resize, but the whole theInfo element adapts in size. So making certain the description element is the lower right corner within theInfo area, so that you can resize everything (theInfo area) from the lower right corner.
			// originally the description element was the only one to resize simply becuause it can have a lot of content
			// some may want to make the description area bigger for a more comfortable read
			{
				if (childrenLoaded && synonymsLoaded && distributionsLoaded && vernacularNamesLoaded)
				{
					theInfo.append(superElement);
					if (allDescriptions.getBoundingClientRect().height >260)
					{
						allDescriptions.style.height = "260px";
						allDescriptions.style["overflow-y"] = "auto";
					}
					if (superElement.getBoundingClientRect().width >= 600 && !isMobile) superElement.style.width = "600px";
					if (superElement.getBoundingClientRect().height >= 300)
					{
						superElement.style.height = "300px";
						if (!isMobile) superElement.classList.add('resizable-content');
						if (!isMobile) resizeObserver.observe(superElement); // adjusts the text-div (allDescriptions) to the parent div (superElement) when resizing the parent.
					}
					superElement.animate(fadeIn, fadeTime);
				}
				else setTimeout(checkOtherElementsLoaded, 100);
			}
		}
	});
	
	fetch((localDjangoDB) ? '/life/species/'+keyID+'/distributions' : 'https://api.gbif.org/v1/species/'+keyID+'/distributions?limit=500')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('DISTRIBUTIONS: ');
		console.log(incoming);
		
		const allDistributions = g(); 
		if (incoming.results.length !== 0)
		{
			let rememberPlaces = "";
			let localitiesCounter = 0;
			for (const distribution of incoming.results)
			{	
				const theLocality = g();
				theLocality.style['margin-right'] = '15px';
				if (distribution.locality !== undefined)
				{
					if (rememberPlaces.indexOf(distribution.locality) !== -1) continue;
					theLocality.innerHTML = distribution.locality;
					rememberPlaces += distribution.locality;
					localitiesCounter++;
				}							
				if (distribution.country !== undefined)
				{
					let theCountry = "";
					for (let place in countryCodes)
					{
						if (countryCodes[place].Code === distribution.country.toUpperCase())
						{
							theCountry = countryCodes[place].Name;
							break;
						}
					}
					if (theCountry === "" || rememberPlaces.indexOf(theCountry) !== -1) break;
					theLocality.innerHTML = theCountry;
					rememberPlaces += theCountry;
					localitiesCounter++;
					if (distribution.establishmentMeans !== undefined)
					{
						let establishment = distribution.establishmentMeans.toLowerCase()
						establishment = establishment.replace(establishment[0], establishment[0].toUpperCase());
						theLocality.innerHTML +=  " â€¢ <i>"+establishment+"</i>";
					}
					if (distribution.threatStatus !== undefined) // https://gbif.github.io/gbif-api/apidocs/src-html/org/gbif/api/vocabulary/ThreatStatus.html
					{
						if (distribution.threatStatus !== "NOT_EVALUATED" && distribution.threatStatus !== "NOT_APPLICABLE" && distribution.threatStatus !== "DATA_DEFICIENT")
						{
							let threat = caps(threatStatus);
							threat = threat.replace("_"," ");
							theLocality.innerHTML +=  " â€¢ <i>"+threat+"</i>";
						}
					}
				}
				if (isMobile) // some servers somewhere (that feed the GBIF) seem to be uploading texts without white spaces, which then don't get line breaks (as they're "one word") and throw apart the styling of the div as the div expands over the body space. on mobile devices that's a real interaction and visuality problem.
				{
					let allWords = theLocality.innerHTML.split(' ');
					let correctedWords = "";
					for (const word of allWords)
					{	
						if (word.length > 20)
						{
							let twenty = 0;
							while(true)
							{
								correctedWords += word.slice(twenty,twenty+20)+"-";
								twenty += 20;
								if (twenty > word.length) break;
							}
						}
						else correctedWords += word+' ';
					}
					theLocality.innerHTML = correctedWords;
				}
				allDistributions.append(theLocality);
			}
			const superElement = g();
			superElement.classList.add('baseBlock');
			superElement.style['background-color'] = `hsl(${theColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			const elementTitle = g();
			elementTitle.innerHTML = '<strong>LOCALITIES</strong>';
			superElement.append(elementTitle);
			if (localitiesCounter > 5)
			{
				superElement.style.height = "220PX";
				allDistributions.style.height = "150px";
				allDistributions.style["overflow-y"] = "auto";
				allDistributions.style["overflow-x"] = "hidden";
			}
			superElement.append(allDistributions);
			theInfo.append(superElement);
			superElement.animate(fadeIn, fadeTime);
			allSuperElements.push(superElement);
			if (superElement.getBoundingClientRect().width > 600 && !isMobile) superElement.style.width = '600px';
			
		}
		distributionsLoaded = true;
	})
	
	fetch((localDjangoDB) ? '/life/species/'+keyID+'/vernacularNames' : 'https://api.gbif.org/v1/species/'+keyID+'/vernacularNames')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('VERNACULAR NAMES');
		console.log(incoming);
		if (incoming.results.length !== 0)
		{
			let nameCount = 0;
			let vernacularNames = g();
			let rememberNames = "";
			for (const name of incoming.results)
			{ 
				// there're often many duplicates
				if (name.language !== 'eng' && name.language !== undefined) continue;
				let tempName = name.vernacularName.replace("â€™","'");
				if (rememberNames.toLowerCase().indexOf(tempName.toLowerCase()) !== -1) continue; // removes duplicates like "Layard's beaked whale" and "Layardâ€™s beaked whale"
				tempName = tempName.replace("'"," "); 
				if (rememberNames.toLowerCase().indexOf(tempName.toLowerCase()) !== -1) continue;// removes duplicates like "Layard's beaked whale" and "Layard s beaked whale"
				if (tempName.charAt(tempName.length-1)==="s") tempName = tempName.slice(0, tempName.length-1);
				if (rememberNames.toLowerCase().indexOf(tempName.toLowerCase()) !== -1) continue; // throws out the duplicate of plurals and singulars that comes second: if 'Whale' (ORDER) is first, then 'Whales' will be dismissed.
				
				const theName = g();
				theName.innerHTML = name.vernacularName;
				theName.style["margin-right"] = "15px";
				theName.onclick = ()=>
				{
					console.log("SEARCHING FOR "+theName.innerHTML+ " IN RANK CONDITION "+taxaKeys[y]);
					search(theName.innerHTML, taxaKeys[y]);
				}
				theName.style.cursor = 'pointer';
				vernacularNames.append(theName);
				rememberNames += name.vernacularName;
				nameCount++;
			}
			const superElement = g();
			superElement.classList.add('baseBlock');
					
			superElement.style['background-color'] = `hsl(${theColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			const elementTitle = g();
			elementTitle.innerHTML = '<strong>VERNACULAR NAMES</strong>';
			if (nameCount > 5)
			{
				superElement.style.height = "220px";
				vernacularNames.style.height = "150px";
				vernacularNames.style["overflow-y"] = "auto";
			}
			superElement.append(elementTitle, vernacularNames);
			theInfo.append(superElement);
			superElement.animate(fadeIn, fadeTime);
			allSuperElements.push(superElement);
			if (superElement.getBoundingClientRect().width > 600 && !isMobile) superElement.style.width = '600px';
		}
		vernacularNamesLoaded = true;
	})
	
	// IMAGES
	if (y > 2) // makes certain that kingdom, phylum and class don't fetch media. The images are not of use for this app. The images for kingdom 'animalia' e.g. are a lot, and sometimes very specific (like dinosaur bones being dug out...) and to think that every time someone clicks on animalia this would show up, esp since this kingdom will be part of every animal query.
	{
		fetch((localDjangoDB) ? '/life/species/'+keyID+'/media' : 'https://api.gbif.org/v1/species/'+keyID+'/media')
		.then(response => response.json())
		.then(incoming =>
		{
			console.log('MEDIA');
			console.log(incoming);
			if (incoming.results.length !== 0 )
			{
				const allImageSources = 
				{
					'links': [],
					'descriptions': [],
					'colors': [],
				};
				for (const image of incoming.results)
				{
					const frameColor = `hsl(${theColor}, 60%, 60%)`;
					allImageSources.links.push(image.identifier);
					allImageSources	.colors.push(frameColor);
					let description = "";
					if (image.description !== undefined) description = "<strong>Description</strong><br>"+ image.description;
					let creator = "";
					if (image.creator !== undefined) creator = "<br><br><strong>Creator:</strong><br>"+image.creator;
					allImageSources	.descriptions.push(description+creator);
				}
				displayImages(allImageSources, GBIFResult, 'MEDIA', y);
			}
		});
	}
	
	// FETCH OCCURRENCES
	fetch('/life/occurrence/search?speciesKey='+keyID+'&limit=300')
	.then(response => response.json())
	.then(async (incoming) =>
	{
		let allImageSources = 
		{
			'links': [],
			'descriptions': [],
			'colors': [],
		};
		
		console.log('OCCURRENCES LOCAL DJANGO');
		allImageSources = await readOccurrences(incoming, allImageSources);
		
		fetch('https://api.gbif.org/v1/occurrence/search?speciesKey='+keyID+'&limit=500') // GBIF caps it at 300 though
		.then(response => response.json())
		.then(async (incoming2) =>
		{
			console.log('OCCURRENCES GBIF');
			allImageSources = await readOccurrences(incoming2, allImageSources);
			displayImages(allImageSources, GBIFResult, 'OCCURRENCE', y);
		});
	});

	function readOccurrences(incoming, allImageSources)
	{
		console.log(incoming);
		if (incoming.results.length !== 0)
		{
			
			let total = 0;
			for (const occurrence of incoming.results)
			{
				if (occurrence.media.length > 0) // media are just an optional data within occurrences.
				{
					total += occurrence.media.length;
					for (const image of occurrence.media)
					{
						//console.log(image);
						let hasImage = false;
						if (image.type !== undefined && image.identifier !== undefined)
						{
							if (image.type === "StillImage") // 2nd condition "image.format.indexOf('image') !== -1" has been dismissed. They're rare cases that simply have no image.format key, but everything else being fine.
							{
								allImageSources.links.push(image.identifier);
								hasImage = true;
							}
						}
						else if (image.references !== undefined) // sometimes, but rarely, there may just be a single key in the media object, e.g. called "references" or "identifier" with a media-link as the value. It can be an image, but could also be a video or other material.
						{
							//for (const fileType of imageFileTypes) // making certain it's an image.
								//if (image.references.search(fileType) !== -1) 
							//console.log('IMAGE.REFERENCES: '+image.references);
							allImageSources.links.push(image.references);
							hasImage = true;
						}
						else if (image.identifier !== undefined)
						{
							//for (const fileType of imageFileTypes)
								//if (image.identifier.search(fileType) !== -1)
							//console.log('IMAGE.IDENTIFIER: '+image.references);
							allImageSources.links.push(image.references);
							hasImage = true;
						}
						else console.log("UNUSUAL IMAGE SOURCE: "+occurrence);
						if (!hasImage) continue;
							
						// LOCALITY
						let locality = "";
						if (occurrence.locality !== undefined) locality = caps(occurrence.locality);
						let county = ""
						if (occurrence.county !== undefined) county = caps(occurrence.county);
						let localityCommaCounty = "";
						if (locality !== "" && county !== "") localityCommaCounty = ", ";
						let country = "";
						if (occurrence.country !== undefined) country = caps(occurrence.country);
						let countryComma = "";
						if ((county !== "" || locality !== "") && country !== "") countryComma = ", ";
						let continent = "";
						if (occurrence.continent !== undefined) continent = caps(occurrence.continent);
						let continentComma = "";
						if ((locality !== "" || county !== "" || country !== "") && continent !== "") continentComma = ", ";
						let localityTitle = "";
						if (locality !== "" || county !== "" || country !== "" || continent !== "") localityTitle = "<strong>Locality: </strong>";
						
						// OCEAN AND ISLAND
						let island = "";
						if (occurrence.island !== undefined) island = caps(occurrence.island);
						let waterBody = ""
						if (occurrence.waterBody !== undefined) waterBody = caps(occurrence.waterBody);
						let islandCommaWaterBody = "";
						if (island !== "" && waterBody !== "") islandCommaWaterBody = ", ";
						let islandWaterBodyTitle = "";
						if (island !== "" || waterBody !== "") islandWaterBodyTitle = "<br><strong>Ocean:</strong> ";
						let elevation = "";
						if (occurrence.elevation !== undefined) elevation = "<br>Elevation: "+occurrence.elevation+"m";
						let depth = "";
						if (occurrence.depth !== undefined) depth = "<br>Depth: "+occurrence.depth+"m";
						let theLocality = localityTitle+locality+localityCommaCounty+county+countryComma+country+continentComma+continent+islandWaterBodyTitle+island+islandCommaWaterBody+waterBody+elevation+depth;
						theLocality = theLocality.replaceAll('_',' ');
						
						// LONGITUDE & LATITUDE
						let latitudeLongitude = "";
						if (occurrence.decimalLatitude !== undefined && occurrence.decimalLongitude !== undefined) latitudeLongitude = "<br><strong>Coordinates:</strong> "+occurrence.decimalLatitude+"Â° "+occurrence.decimalLongitude+"Â°";
						
						// DATE AND TIME OF RECORD
						let eventDate = "";
						if (occurrence.eventDate !== undefined) eventDate = occurrence.eventDate;
						else if (occurrence.georeferenceTime !== undefined) eventDate = occurrence.georeferenceTime; //"2023-01-02T10:01:55", both eventDate and georeference have this format.
						
						// OR:
						let day = 0; let month = 0; let year = 0;
						if (occurrence.day !== undefined && occurrence.month !== undefined && occurrence.year !== undefined) {day = occurrence.day; month = occurrence.month; year = occurrence.year}
						let eventTime = "";
						if (occurrence.eventTime !== undefined) eventTime = occurrence.eventTime; // "10:01:55"
						
						// COMBINE DATE & TIME
						let dateAndTime = "";
						if (eventDate !== "")
						{
							dateAndTime = eventDate.split('T');
							let month = months[parseInt(dateAndTime[0].substr(5,2))-1]; // -1 as first month / Jan starts at 01, and so on.
							if (dateAndTime[1] =="00:00:00") dateAndTime[1] = "";
							else dateAndTime[1] = ", "+dateAndTime[1]+" local time.";
							let updatedDate = dateAndTime[0].replace(/-[0-9]{2}-/," "+month+" ");
							dateAndTime = "<br><br><strong>Date of record:</strong> "+updatedDate+dateAndTime[1];
						}
						else if(year > 0)
						{
							if (day === 0) day = "";
							else day = " "+day
							if (month === 0) month = "";
							else month = " "+months[month-1];
							if (eventTime !== "" && eventTime !== "00:00:00")  eventTime = ", "+eventTime+" local time.";
							else eventTime = "";
							dateAndTime = "<br><br><strong>Date of record:</strong> "+year+month+day+eventTime;
						}
						let recordedBy = "";
						if (occurrence.recordedBy !== undefined) recordedBy = "<br><strong>Recorded by:</strong> "+occurrence.recordedBy;
						
						let indentifiedBy = "";
						if (occurrence.indentifiedBy !== undefined) indentifiedBy = "<br><br><strong>Identified by </strong><br>"+ occurrence.indentifiedBy;
						
						// SUBJECT OBSERVATION DATA
						let sex = "";
						if (occurrence.sex !== undefined) sex = "<br>Sex: "+occurrence.sex.toLowerCase();
						let individualCount = "";
						if (occurrence.individualCount !== undefined) individualCount = "<br>Individual count: "+ occurrence.individualCount; // integer
						let isInCluster = "";
						if (occurrence.isInCluster !== undefined) // boolean
						{
							if (occurrence.isInCluster) isInCluster = "<br>Subject is part of a cluster.";
							else isInCluster = "<br>Subject is not part of a cluster.";
						}
						let conservationStatus = "";
						if (occurrence.iucnRedListCategory !== undefined) conservationStatus = "<br>Conservation status: <strong>"+ caps(iucnRedList[occurrence.iucnRedListCategory])+"</strong>";
						let establishmentMeans = ""
						if (occurrence.establishmentMeans !== undefined) establishmentMeans = "<br>Establishment means: "+caps(occurrence.establishmentMeans);
						let basisOfRecord = ""
						if (occurrence.basisOfRecord !== undefined) basisOfRecord = "<br>Basis of record: "+ caps(occurrence.basisOfRecord.replace('_',' ')); // "HUMAN_OBSERVATION"
						let identificationRemarks = "";
						if (occurrence.identificationRemarks !== undefined) identificationRemarks = "<br>Identification remarks: "+occurrence.identificationRemarks;
						let license = "";
						if (occurrence.license !== undefined)
						{
							if (occurrence.license.indexOf('creativecommons') !== -1) license = "<br>License: Creative Commons"; // instead of a link to the license on creativecommons.org.
							else license = "<br>License: "+ occurrence.license;
						}
						let institutionCode = "";
						if (occurrence.institutionCode !== undefined) institutionCode = "<br>Institution code: "+occurrence.institutionCode;
						let subjectObservationData = sex+individualCount+isInCluster+conservationStatus+establishmentMeans+basisOfRecord+identificationRemarks+license+institutionCode;
						if (subjectObservationData.length > 0) subjectObservationData = "<br><br><strong>Subject Observation Data</strong>"+subjectObservationData; // adding title 

						// PUBLISHER
						let publishingCountry = "";
						if (occurrence.publishingCountry !== undefined)
						{
							for (let countries in countryCodes)
							{
								if (publishingCountry === countryCodes[countries].Code)
								{
									publishingCountry = countryCodes[countries].Name;
									break;
								}
							}
						}
						let publisher = "";
						if (image.publisher !== undefined) publisher = image.publisher;
						let rightsHolder = "";
						if (image.rightsHolder !== undefined) rightsHolder = "<br><strong>Rightsholder: </strong>"+ image.rightsHolder;
						let publisherTitle = "";
						if (publisher !== "") publisherTitle = "<br><br><strong>Publisher: </strong>";
						let publishedIn = "";
						if (publisher !== "" && publishingCountry !== "") publishedIn = ", published in "+publishingCountry;
						let publishing = publisherTitle+publisher+publishedIn+rightsHolder;

						// SCIENTIFIC NAME
						let scientificName = "";
						if (occurrence.scientificName !== undefined) scientificName = "<br><br><strong><i>Scientific Name</i></strong><br>"+occurrence.scientificName;
						
						// ASSEMBLING OCCURRENCE DATA
						const descriptions = theLocality+latitudeLongitude+dateAndTime+recordedBy+indentifiedBy+subjectObservationData+publishing+scientificName;
						allImageSources.descriptions.push(descriptions);
						allImageSources.colors.push("rgb(33,37,41)");
					}
				}
			}
			console.log('TOTAL: ' +total);
			for (let x = 0; x < allImageSources.links.length; x++) if (allImageSources.links[x] === undefined)
			{
				console.log('FOUND UNDEFINED');
				allImageSources.links.splice(x,1);
				allImageSources.descriptions.splice(x,1);
				allImageSources.colors.splice(x,1);
				x--;
			}
			for (let x = 0; x < allImageSources.links.length; x++) // throws out duplicates. They're rare, but come up once in a while.
			{
				for (let z = 0; z < allImageSources.links.length; z++)
				{
					if (x === z) continue;
					if (allImageSources.links[x] === allImageSources.links[z])
					{
						console.log('+ + + DUPLICATE + + +\n\nAt Indeces: '+x+' and '+z+'\n'+allImageSources.links[x]+'\n'+allImageSources.links[z]);
						allImageSources.links.splice(x,1);
						allImageSources.descriptions.splice(x,1);
						allImageSources.colors.splice(x,1);
						z--;
						x--;
					} 
				}
			}	
		}
		return allImageSources;
	}	
	
	/* DISMISSED FETCH CALLS
	Verbatim-get always responds with an error with the message that there's no entity. No idea how an object would look like.
	fetch('https://api.gbif.org/v1/species/'+keyID+'/verbatim') // ???
	
	For this app not of use. Also: Canonical name, authorship, year and scientific name (which is: canonical name + authorship + year) are also included in the basic query result object / ID species object.
	fetch('https://api.gbif.org/v1/species/'+keyID+'/name')

	Lists other catalogues where this rank object is present. For this app we stay in the GBIF BACKBONE TAXONOMY checklist dataset.
	fetch('https://api.gbif.org/v1/species/'+keyID+'/related?limit=500')
	
	Very most results don't yield any other (re)combinations / basionym names.
	fetch('https://api.gbif.org/v1/species/'+keyID+'/combinations')
	
	Species profiles and references are scientific source and catalogue references for this species / rank object. For this app, which is just about browsing species for curious (non-life-scientist) people, this information is dismissable.
	fetch('https://api.gbif.org/v1/species/'+keyID+'/references')
	fetch('https://api.gbif.org/v1/species/'+keyID+'/speciesProfiles')
	
	I've not found one type specimen, I can't even tell what exactly its information purpose should be.
	fetch('https://api.gbif.org/v1/species/'+keyID+'/typeSpecimens')
	
	Parents not necessary as they're already loaded from the queried GBIF species / rank object.
	fetch('https://api.gbif.org/v1/species/'+keyID+'/parents') 
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('PARENTS: ');
		console.log(incoming);
		if (incoming.length !== 0)
		{
			let parents = g();
			parents.classList.add('baseBlock');
			parents.style['background-color'] = `hsl(${theColor}, 60%, 60%)`;
			parents.innerHTML = '<strong>PARENT TREE</strong><br>';
			for (let parent in incoming)
			{
				parents.innerHTML += "<strong>" + incoming[parent].rank.toUpperCase()+"</strong> "+incoming[parent].canonicalName+"<br>";
			}
			flexPartDescription.append(parents);
			console.log(parents.clientHeight);
		}
	})*/
}