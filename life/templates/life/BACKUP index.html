{% extends "life/layout.html" %}
{% load static %}
{% block body %}


<script>
const body = document.querySelector('body');
body.style['background-color'] = '#3C7185';

// AN OVERLAY-BACKGROUND FOR DISPLAYING IMAGES FULL WINDOW
const fullWindow = document.createElement('div');
fullWindow.style['background-color'] = 'rgba(0,25,50,0.8)';
fullWindow.style.position = 'absolute';
fullWindow.style.left = '0px';
// fullWindow.style.width = window.innerWidth+'px';
// fullWindow.style.height = window.innerHeight+'px';
fullWindow.style.display = 'none';
body.appendChild(fullWindow);


/* ANIMATION
const loadAni = document.createElement('div');
loadAni.classList.add('loader');
fullWindow.appendChild(loadAni);
const loadRotate =
[
  { transform: "rotate(0) translate(-50%, -50%)" },
  { transform: "rotate(360deg) translate(-50%, -50%)"},
];
const loadTiming =
{
  duration: 3000,
  iterations: Infinity,
};
loadAni.animate(loadRotate, loadTiming);
ANIMATION END */


const arrow = document.createElement('div');
arrow.classList.add('fullWindowImageNavigationArrow');
const arrowLeft = arrow.cloneNode();
const arrowRight = arrow.cloneNode();
arrowLeft.style.left = '5%';
arrowRight.style.left = '95%';
arrowLeft.innerHTML = '⪡';
arrowLeft.onmouseover = () => {arrowLeft.style.cursor = 'pointer'; arrowLeft.style.color = 'deepskyblue';}
arrowRight.onmouseout = () =>
{
	arrowRight.style.color = 'white';
	arrowRight.style.cursor = 'default';
};
arrowLeft.onmouseout = () =>
{
	arrowLeft.style.color = 'white';
	arrowLeft.style.cursor = 'default';
};
fullWindow.appendChild(arrowRight);
fullWindow.appendChild(arrowLeft);

fullWindowNavigationStates();
function fullWindowNavigationStates(state)
{
	arrowRight.style.opacity = 1;
	arrowLeft.style.display = 'block';
	arrowRight.innerHTML = '⪢';
	arrowRight.onmouseover = () => {arrowRight.style.cursor = 'pointer'; arrowRight.style.color = 'deepskyblue';}
	//loadAni.style.display = 'none';
	
	if (state === "atBeginning")
	{
		arrowLeft.style.display = 'none';
	}
	if (state === "atEndDownloadMore")
	{
		arrowRight.style.opacity = 0.5;
		arrowRight.onmouseover = () => {arrowRight.style.cursor = 'default'; arrowRight.style.color = 'white';}
		//loadAni.style.display = 'block';
	}
	if (state === "atEndNoMoreDownloads")
	{
		arrowRight.innerHTML = '▣';
		arrowRight.onmouseover = () => {arrowRight.style.cursor = 'default'; arrowRight.style.color = 'white';}
	}
}

arrowLeft.addEventListener('click', ()=>
{
	if (thisImageIndex > 0)
	{
		thisImageIndex--;
		displayImageFullWindow();
		if (thisImageIndex === 0) fullWindowNavigationStates('atBeginning');
		else fullWindowNavigationStates();
	}
});

arrowRight.addEventListener('click', async () =>
{
	if (thisImageIndex < fullWindowImagesArray.length-1)
	{
		thisImageIndex++;
		displayImageFullWindow();
		fullWindowNavigationStates();
	}
	else if (await functionAddNextImage(true) && !downloadedAllImages)
	{
		thisImageIndex++;
		displayImageFullWindow();
	}
});





var fullWindowImage = document.createElement('IMG');
fullWindow.appendChild(fullWindowImage);
var thisImageIndex = 0;
var fullWindowImagesArray = [];
var fullWindowDisplayActive = false;
var downloadedAllImages = false;
var functionAddNextImage;


window.onkeydown = function(event) 
{
	let key = event.keyCode || event.which;
	const escape = 27;
	const arrowLeftKey = 37;
	const arrowRightKey = 39;
	
	if (key === escape)
	{
		fullWindow.style.display = 'none';
		body.style.overflow = 'auto';
	}
	if(key === arrowLeftKey && thisImageIndex > 0)
	{
		thisImageIndex--;
		displayImageFullWindow();
	}
	if(key === arrowRightKey && thisImageIndex < fullWindowImagesArray.length-1)
	{
		thisImageIndex++;
		displayImageFullWindow();
	}
}

// + + + ANIMATION + + +
const shape = document.createElementNS("http://www.w3.org/2000/svg", "circle");
shape.setAttribute("cx", 50); // coordinates of circle center within the svg box.
shape.setAttribute("cy", 50);
shape.setAttribute("r",  40); // for ellipses use rx and ry
shape.setAttribute("fill", "rgba(0,0,0,0)");
shape.setAttribute("stroke", "deepskyblue");
shape.setAttribute("stroke-width",12);
shape.setAttribute("stroke-linecap","round");

const filter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
filter.setAttribute("id","f1");
const dropShadow = document.createElementNS("http://www.w3.org/2000/svg", "feDropShadow");
dropShadow.setAttribute('dx',0);
dropShadow.setAttribute('dy',0);
dropShadow.setAttribute('stdDeviation','2');
dropShadow.setAttribute('flood-color', 'deepskyblue');
filter.appendChild(dropShadow);

export const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
svg.style.width = '100px';
svg.style.height = '100px';
svg.style.position = 'relative';
// svg.style.left = '100px';
// svg.style.top = '100px';
// svg.setAttribute('viewBox','0 0 100 100'); // we don't need scaling. https://css-tricks.com/scale-svg/
//svg.style.transform = 'translate(-50%,-50%)';
svg.appendChild(shape);
svg.appendChild(filter);
// shape.setAttribute("filter","url(#f1)"); // uncomment this to have a weak glow.
body.appendChild(svg);


// stroke length unit is the CIRCUMFERENCE calculated from the r dimension pixels: 2*pi*r
// it would be nicer to have degrees or percentages, since it is a circle. But that's how SVG works.
// so for a circle stroke of three dashes and three gaps of equal lengths the 'stroke-dasharray' value would be (2*pi*r)/6.
// SYNTAX: in the CSS styling it's 'stroke-dasharray', in JS in the list-of-objects (here: loadRotate) for the animation function (element.animate) it's strokeDasharray. It doens't take strings as names like 'stroke-dasharray' or in brakets. Multiple values are in inverted comma: 'number, number, ...' (not in array like [1,3]). This in contrast to setAttribute for SVGs: shape.setAttribute('stroke-dasharray', [number, number])
// TIP: create shapes in Illustrator or another vector program, save as SVG and open it in a text editor. Edit the file to see on the fly how the SVG is constructed. You can DIRECTLY COPY it over to your HTML space to take effect in your app.

const circum = Math.PI*2*shape.r.baseVal.value;
const transition = ((circum/4)*0.05).toString()+","+((circum/4)*0.95).toString();
const loadRotate =
[
	{ strokeDasharray: transition},
	{ strokeDasharray: circum/8},
	{ strokeDasharray: circum/8, strokeDashoffset: circum/4},
	{ strokeDasharray: transition, strokeDashoffset: circum/4},
];
const loadTiming =
{
  	duration: 2000,
  	iterations: Infinity,
};
shape.animate(loadRotate, loadTiming);

const fadeOut =
[
	{opacity: 1},
	{opacity: 0}
]
const fadeIn =
[
	{opacity: 0},
	{opacity: 1}
]
export const fadeTime = 333;
export const timing = {duration: fadeTime};
const aString = "but how about variables?"
export aString;


// + + + ANIMATION END + + +



//loadAni.style.display = 'none';
// fullWindow.appendChild(loadAni);


/*
huntForSymbols = document.createElement('div');
body.appendChild(huntForSymbols);
var counter = 0;
var otherCounter = 0;
var begin = 0;
while (counter < 15000)
{
	begin += counter;
	huntForSymbols.innerHTML += '&#'+begin;
	if (otherCounter == 50)
	{
		otherCounter=-1;
		huntForSymbols.innerHTML += "<br>";
	}
	counter ++;
	otherCounter++;
}
*/

// SOME INSPIRATION FOR SYMBOLS TO USE
// ᐷᐷ⩹⩺⩻⩼⩽⩾⩿⪀⪁⪂⪃⪄⪅⪆⪇⪈⪉⪊⪋⪌⪍⪎⪏⪐⪑⪒⪓⪔⪕⪖⪗⪘⪙⪚⪛⪜⪝⪞⪟⪠⪡⪽⪾
// ≥≦≧≨≩≪≫≬≭≮≯≰≱≲≳≴≵≶≷≸≹≺≻≼≽≾≿⊀⊁⊂⊃⊄⊅⊆⊇⊈⊉⊊⊋⊌⊍⊎⊏⊐⊑⊒⊓⊔
// ⪢ ⦾⦿⧀⧁⧂⧃⧄⧅⧆⧇⧈⧉⧊⧋⧌⧍⧎⧏⧐
// ⩹⩺⩻⩼⩽⩾⩿⪀⪁⪂⪃⪄⪅⪆⪇⪈⪉⪊⪋⪌⪍⪎⪏⪐⪑⪒⪓⪔⪕⪖⪗⪘⪙⪚⪛⪜⪝⪞⪟⪠⪡
// ⪢⪣⪤⪥⪦⪧⪨⪩⪪⪫⪬⪭⪮⪯⪰⪱⪲⪳⪴⪵⪶⪷⪸⪹⪺⪻⪼⪽⪾⪿⫀⫁⫂⫃⫄⫅⫆⫇⫈⫉⫊⫋⫌⫍⫎⫏⫐⫑⫒⫓⫔
// ⫕⫖⫗⫘⫙⫚⫛⫝̸⫝⫞⫟⫠⫡⫢⫣⫤⫥⫦⫧⫨⫩⫪⫫⫬⫭⫮⫯⫰⫱⫲⫳⫴⫵⫶⫷⫸ ▢▣
// ⋖⋗⋘⋙ ⊙ ᘮᘯᘰᘱᘲᘳᗜᗝᗞᗟᗠᗡᗢᗣᗤᗥᗦᗧᗨᗩᗪᗫᗬᗭᕭᕮᕯᕰᕱᕲᕳ
// ᓓᓔᓕᓖᓗᓘᓙᓚᓛᓜᓝᓞᓟᓠᓡᓢᓣᓤᓥᓦᓧᓨᓩᓪ
// ᐶᐷᐸᐹᐺᐻᐼᐽᐾᐿᑀᑁᑂᑃᑄᑅᑆᑇᑈᑉᑊᑋᑌᑍᑎᑏᑐᑑᑒᑓᑔᑕᑖᑗᑘᑙᑚᑛᑜᑝᑞᑟᑠᑡᑢᑣᑤᑥ

const taxaKeys = ["kingdom", "phylum", "class", "order", "family", "genus", "species"];

// SEARCH SECTION
const searchSection = document.createElement('div');
const textareaNameSearch = document.createElement('input');
const rankCondition = document.createElement('select');
const searchGo = document.createElement('button');
const howTo = document.createElement('div');
const howToText = document.createElement('div');

for (key in taxaKeys)
{
	let opt = document.createElement('option');
	opt.value = taxaKeys[key];
	opt.innerHTML = taxaKeys[key].toUpperCase();
	if(taxaKeys[key] == 'species') opt.selected=true;
	rankCondition.appendChild(opt);
}

const seperation = document.createElement('option');
seperation.value = 'seperation';
seperation.innerHTML = '--------';
rankCondition.appendChild(seperation);
const any = document.createElement('option');
any.value = 'any';
any.innerHTML = 'ANY';
rankCondition.appendChild(any);
const highestRank = document.createElement('option');
highestRank.value = 'highestRank';
highestRank.innerHTML = 'HIGHEST RANK';
rankCondition.appendChild(highestRank);
const allRanks = document.createElement('option');
allRanks.value = 'allRanks';
allRanks.innerHTML = 'ALL RANKS';
rankCondition.appendChild(allRanks);
const seperation2 = document.createElement('option');
seperation2.value = 'seperation';
seperation2.innerHTML = '--------';
rankCondition.appendChild(seperation2);
const canonicalName = document.createElement('option');
canonicalName.value = 'canonicalName';
canonicalName.innerHTML= 'SCIENTIFIC NAME';
rankCondition.appendChild(canonicalName);

textareaNameSearch.id = 'textareaNameSearch';
rankCondition.id = 'rankCondition';
searchGo.id = 'searchGo';
searchGo.innerHTML = 'GO'
howTo.id = 'howTo';
howTo.innerHTML = "?";
howToText.id = 'howToText';
howToText.innerHTML = "● This app allows you to search the <strong><i>GLOBAL BIODIVERSITY INFORMATION FACILITY (GBIF)</strong></i><br>● You can query using vernacular / folk names.<br><br><i>FYI:</i><br>When using vernacular names, sometimes there can be confusion due to the nature of vernacular or folk names.<br>E.g. searching for SPECIES 'whale' will yield 58 species of whale where 'whale' is part of the name, like southern right whale, bowhead whale and whaleshark, even though the latter is a shark. But if you searched for SPECIES 'dolphin' you'll be given 48 species that would not appear within the finds for 'whale'. Scientifically, dolphins are whales, but in their own FAMILY rank, beneath the ORDER rank Cetacea (whales); for the same reason killer whales would be missing in the 'dolphin' results, even though Orcas belong to the FAMILY of dolphins. Likewise, searching for 'whale' in the FAMILY rank would yield ten families of whales where the dolphin family would be missing as well.";

howToText.style.display = 'none';
howTo.addEventListener('click',() =>
{
	if (howToText.style.display === 'none')
	{
		howToText.style.display = 'block';
	}
	else
	{
		howToText.style.display = 'none';
	}
})
searchSection.id = 'searchSection';
searchSection.appendChild(textareaNameSearch);
searchSection.appendChild(rankCondition);
searchSection.appendChild(searchGo);
searchSection.appendChild(howTo);
searchSection.appendChild(howToText);
body.append(searchSection);
// END SEARCH SECTION

// RESULT OVERVIEW SECTION
const resultOverview = document.createElement('div');
resultOverview.classList.add('blockRow');
resultOverview.classList.add('flexPart');
body.append(resultOverview);
// END RESULT OVERVIEW SECTION

searchSection.addEventListener('change', ()=>
{
	if (rankCondition.value === 'seperation')
	{
		rankCondition.value = 'species';
	}
	if (rankCondition.value === 'highestRank')
	{
		rankCondition.style['width'] = '200px';
	}
	else if (rankCondition.value === 'allRanks')
	{
		rankCondition.style['width'] = '160px';
	}
	else if (rankCondition.value === 'canonicalName')
	{
		rankCondition.style['width'] = '230px';
	}
	else rankCondition.style['width'] = '140px';
})

searchGo.addEventListener('click',()=>
{
	if (textareaNameSearch.value.trim() !== "")
	{
		search(textareaNameSearch.value.trim(), rankCondition.value);
		textareaNameSearch.value="";
	}
})
/*
window.onkeydown = function(event)
{
	const enterKey = 13;
	const arrowUp = 38;
	const arrowDown = 40;
	let key = event.keyCode || event.which;
	if (key === enterKey && textareaNameSearch.value.trim() !== "" && (textareaNameSearch === document.activeElement || rankCondition === document.activeElement))
	{
		search(textareaNameSearch.value.trim(), rankCondition.value);
		textareaNameSearch.value="";
	}
	
	if (key === arrowDown && rankCondition.value === 'species')
	{
		setTimeout(()=> {rankCondition.value = 'any'},	50);
	}
	if (key === arrowUp && rankCondition.value === 'any')
	{
		setTimeout(()=> {rankCondition.value = 'species'},	50);
	}
}*/

// DEBUG //
//search('Caperea marginata','canonicalName');
//search('Balaenoptera acutorostrata', 'canonicalName');
search('Rhincodon typus','canonicalName');

var goThroughRanks = 0;
var canonicalQuery = true;
function search(querySubmit, rankSubmit)
{
	let fetchThis = "";
	
	if (isNaN(querySubmit) === false)
	{
		fetchThis = 'https://api.gbif.org/v1/species/'+querySubmit; // if user queries with keyID.
		rankSubmit = 'keyID';
		console.log('key ID query');
	}
	else if (rankSubmit === 'canonicalName')
	{
		fetchThis = 'https://api.gbif.org/v1/species?name='+querySubmit+'&datasetKey=d7dddbf4-2cf0-4f39-9b2a-bb099caae36c';
		console.log('canonical name query');
	}
	else if (rankSubmit === 'allRanks')
	{
		for (let rank in taxaKeys)
		{
			search(querySubmit, taxaKeys[rank]);
		}
	}
	else if (rankSubmit === 'highestRank')
	{
		console.log(taxaKeys[goThroughRanks]);
		fetchThis = 'https://api.gbif.org/v1/species/search?q='+querySubmit+"&rank="+taxaKeys[goThroughRanks]+'&qField=VERNACULAR&limit=500&status=ACCEPTED&datasetKey=d7dddbf4-2cf0-4f39-9b2a-bb099caae36c';
	}
	else
	{
		let rankConditionFetchParam;
		if (rankSubmit == 'any') rankConditionFetchParam = "";
		else rankConditionFetchParam = "&rank="+rankSubmit;
		fetchThis = 'https://api.gbif.org/v1/species/search?q='+querySubmit+rankConditionFetchParam+'&qField=VERNACULAR&limit=500&status=ACCEPTED&datasetKey=d7dddbf4-2cf0-4f39-9b2a-bb099caae36c';
		console.log('vernacular name query');
	}
	checkResponse(fetchThis, querySubmit, rankSubmit);
}

function checkResponse(fetchThis, querySubmit, rankSubmit)
{
	fetch(fetchThis)
	.then(response => response.json())
	.then(incoming =>
	{
		// console.log(Object.prototype.toString.call(incoming));
		// console.log(Object.prototype.toString.call(incoming.results));
		// console.log(incoming.results)
		console.log(incoming);
		
		if (rankSubmit === 'keyID' && incoming.key === undefined)
		{
			console.log('Key not found. Returning!');
			return;
		}
		if (rankSubmit !== 'keyID')
		{
			if (incoming === undefined || incoming.results.length === 0)
			{
				console.log('Nothing fetched. Returning!');
				if (rankSubmit === 'highestRank' && goThroughRanks < 7)
				{
					goThroughRanks++;
					search(querySubmit, rankSubmit);
				}
				return;
			}
			else if (rankSubmit === 'highestRank') goThroughRanks = 0;
			
			// Why implementing "auto-search canonical name first every time" didn't work: I wanted to automate that whatever name the user queries, it will first query for a canonical name as there can always be one canonical name (across all ranks); if it wouldn't find something it would instantly go on doing a vernacular name fetch. The implementation worked fine, and for many cases it worked (making strict string comparisons to avoid names in which e.g. 'lemur' appeared, disregarding capitals), but not for every:
			// The test case that broke it: searching for the scientific name 'lemur' will yield the GENUS 'Lemur', which contains the famous (and only) SPECIES 'ring-tailed lemur'. But in fact there're 14 more genera (plural GENUS) of lemur, with 8 FAMILIES and around a 100 SPECIES. Among the 15 genera just happened to be one with the sole scientific name 'Lemur' ...because it found a scientific  name for lemur, with the implementation you couldn't do any other query. And there would be a second find: an insect called "Lemur Hübner" (scientific name) or just 'Lemur' (canonical name). Thus the "scientific name" condition had to be a selectable option after all.
		}
		if (rankSubmit === 'keyID') crawl([incoming], querySubmit, rankSubmit); // when searching for a key ID, it'll not send an array with objects, but the species object directly. So for the crawl function it gets put in an array.
		else crawl(incoming.results, querySubmit, rankSubmit); // gbif may respond with metadata object about the set, with the array of target objects being in '.results'.
	})
	
	// setTimeout(reportFetchStatus, 1000)
}

function reportFetchStatus()
{
	if (stillFetching)
	{
		setTimeout(reportFetchStatus, 1000)
		console.log("STILL FETCHING...");
	}
}

function crawl(data, querySubmit, rankSubmit)
{
	// for every find, add the name of it into its rank. E.g. is the find is the order 'Cetacea' (whale), 'Cetacea' gets appended to the order-array. Nothing else gets added. A species gets only added to the species array, without upwards root information.
	const statsNames = {
		kingdom: [],
		phylum: [],
		class: [],
		order: [],
		family: [],
		genus: [],
		species: [],
	}
	// ... do the same with keys (integer IDs)
	const statsKeys = structuredClone(statsNames);
	
	// CAUTION for python-thinkers: in for-in loop x is a stringified number ('2' instead of 2) ...for-in works most of the time, the interpreter always recognizes it as a number when it needs to. At least most of the time: of course it gets iffy if you want sth like array[x+2] as index. Concerning loops with a lot of content like this one, staying with integers ('number' type in js) is probably safest; meaning classical for or while loop.
	// In the for-of loop, x would become every individual object (e.g. if you have a list of div-elements, x becomes each div-element).
	
	for (let x = 0; x < data.length; x++)
	{
		// FILTER
		if(data[x].synonym === true) continue;
		if(rankSubmit !== 'any' && rankSubmit !== 'canonicalName' && rankSubmit !== 'highestRank' && rankSubmit !== 'keyID' && rankSubmit.toUpperCase() !== data[x].rank) continue;
		// ENDFILTER
		
		rankSubmit = data[x].rank.toLowerCase();
		console.log(rankSubmit);
		statsNames[rankSubmit].push(data[x][rankSubmit]) // the name of the rank member
		statsKeys[rankSubmit].push(data[x].key)
		
		// THE BASIC AREA FOR EACH RESULT
		const blockRow = document.createElement('div');
		blockRow.classList.add('blockRow');
		body.append(blockRow);
		
		// THE COMPONENTS ON THE BASIC AREA
		const flexPartRanks = document.createElement('div');
		flexPartRanks.classList.add('flexPart');
		blockRow.appendChild(flexPartRanks);
		const line = document.createElement('hr');
		line.style.display = 'none';
		blockRow.appendChild(line);
		const flexPartDescription = document.createElement('div');
		flexPartDescription.classList.add('flexPart');
		flexPartDescription.style.display = 'none';
		blockRow.appendChild(flexPartDescription);
		const line2 = document.createElement('hr');
		line2.style.display = 'none';
		blockRow.appendChild(line2);
		const flexPartImages = document.createElement('div');
		flexPartImages.classList.add('flexPartImages');
		flexPartImages.style.display = 'none';
		blockRow.appendChild(flexPartImages);
		// html elements are all a question of order. Here an order is created, while also setting them to display 'none', so that if you make them visible, they show up in the right place.
		
		let color = getRndInteger(0,360);
		
		let openedObjectFirstTime = false;
		let targetRankObject = null;
		let targetRankObjectColor = null;
		let targetRankObjectDescription = null;

		const kingdom = document.createElement('div');
		const phylum = document.createElement('div');
		const classRank = document.createElement('div');
		const order = document.createElement('div');
		const family = document.createElement('div');
		const genus = document.createElement('div');
		const species = document.createElement('div');
		
		const taxaBlocks = [kingdom, phylum, classRank, order, family, genus, species];
		
		// IMAGE ARRAY FOR FULL WINDOW DISPLAY
		const arrayOfImages = [];
		
		for (let y = 0; y < taxaBlocks.length; y++)
		{
			// earlier I had implemented:
			// id = Object.keys(data[x].higherClassificationMap)[taxaRankCounter];
			// the higherClassificationMap is convenient as it gives a list upwards (or downwards?) to the evolutionary root. But looping through the map only works as long as it has all the ranks. The problem is that sometimes a rank is missing, so the list is just shorter, but you can't know which rank is missing as there're no rank names. So I had to come back to the ranks that are given in the fetch-object. If a rank is missing in the higherClassificationMap, it's also missing in fetch-object directly (species object).
			// E.g. "Draco melanopogon" (speciesKey: 5226226) doesn't have an order rank. It's just missing, and as you can see, it's missing both in the higherClassificationMap as well as in the species object.
			taxaBlocks[y].classList.add('baseBlock');
			taxaBlocks[y].style['background-color'] = `hsl(${color}, 50%, 50%)`;
			color += 10;
			const taxaBlockColor = color;
			if (taxaKeys[y] === rankSubmit) targetRankObjectColor = taxaBlockColor;
			let taxaBlockOpened = false; // sole purpose for this variable is to have the mouseover and mouseout events listeners further down not cancel the style of the taxaBlock
			//console.log(data[x][taxaKeys[y]])
			const taxaRank = taxaKeys[y];
			const rankNameKey = taxaKeys[y]+"Key";
			const keyId = data[x][rankNameKey];
			const rankClassification = document.createElement('div');
			const rankName = document.createElement('div');
			if (data[x][taxaKeys[y]] !== undefined && keyId !== undefined) // if rank is not missing
			{
				rankClassification.innerHTML = taxaKeys[y].toUpperCase();
				rankName.innerHTML = data[x][taxaKeys[y]];
				rankClassification.classList.add('rankClassification');
				taxaBlocks[y].appendChild(rankClassification);
				taxaBlocks[y].appendChild(rankName);
				
				const rankDescriptionContent = document.createElement('div');
				rankDescriptionContent.classList.add('rankDescription');
				flexPartDescription.appendChild(rankDescriptionContent);
				let openedTaxaRankFirstTime = false;
							
				// ALL THE FETCHES REGARDING A TAXONOMY RANK OBJECT
				taxaBlocks[y].addEventListener('click',() =>
				{
					display();
				});
				
				function display()
				{
					if (!openedObjectFirstTime)
					{
						// gbifResultOpenClose();
						openedObjectFirstTime = true;
					}
					
					// apparently a direct attribute check like flexPartDescription.style.display === 'flex' doesn't work if it's styled via classList (even though it gets display: 'flex' through the CSS class). Looking through the prototype attributes of flexPartDescription.style in the console reveals that all styling attributes are "", even though the CSS class attributes are clearly in effect. Only if it is here in JS explicitly expressed (flexPartDescription.style.display = 'flex'), then it would be having the attribute in the element styling prototype. So you have to keep interacting over classList and className once you use them. That's JS for you.
					if (taxaRank === rankSubmit && !displayAllRanks) gbifResultOpenClose(false);
					if (displayAllRanks)
					{
						if (!openedTaxaRankFirstTime) fetchEverything(y, keyId, rankDescriptionContent, flexPartImages, taxaBlockColor, 	arrayOfImages);
						openedTaxaRankFirstTime = true;
						if (rankDescriptionContent.className === 'rankDescription')
						{
							rankDescriptionContent.classList.replace('rankDescription', 'hidden');
							taxaBlocks[y].style['background-color'] = 'hsl('+taxaBlockColor+', 50%, 50%)';
							taxaBlockOpened = false;
						}
						else
						{
							rankDescriptionContent.classList.replace('hidden', 'rankDescription');
							taxaBlocks[y].style['background-color'] = 'hsl('+taxaBlockColor+', 70%, 70%)';
							taxaBlockOpened = true;
						}
					}
				}	
				if (taxaKeys[y] === rankSubmit) targetRankObjectDescription = rankDescriptionContent;
			}
			else
			{
				console.log(taxaKeys[y].toUpperCase() +" rank does not exist for "+data[x][rankSubmit]+", "+data[x][rankSubmit+"Key"]+", "+rankSubmit.toUpperCase());
				taxaBlocks[y].innerHTML = "<strong>"+taxaKeys[y].toUpperCase()+"</strong>:<br><i>No rank.</i>"; // Sometimes there just isn't the correct rank; the GBIF decided on the seven most basic / most backbone ranks. In truth there many more ranks, e.g. while the GBIF simply has ORDER, in biology there're also (wikipedia): Magnorder (magnus, 'large, great, important'), Superorder (super, 'above'), Grandorder (grand, 'large'), Mirorder	(mirus, 'wonderful, strange'), then actual ORDER, Suborder (sub, 'under'), Infraorder	(infra, 'below'), Parvorder	(parvus, 'small, unimportant'). An example would be Cetacea (whales): in GBIF they appear as an ORDER, but are actually an Infraorder. Some in-between ranks like toothed whales (Odontoceti) simply don't exist on the GBIF, even though it's a vast Parvorder that contains all the whales that have teeth, like Dolphins; and the FAMILY of dolphins (Delphinidae) has a Superfamily Delphinoidea and a Subfamily Delphininae...
				taxaBlocks[y].style['cursor'] = 'auto';
			}
			
			taxaBlocks[y].addEventListener('mouseover', () =>
			{
				rankClassification.style['color'] = 'deepskyblue';
				if (!taxaBlockOpened) taxaBlocks[y].style['background-color'] = 'hsl('+taxaBlockColor+', 70%, 70%)';
				//taxaBlocks[y].style['border'] = '5px solid white';
			})
			taxaBlocks[y].addEventListener('mouseout', () =>
			{
				rankClassification.style['color'] = 'white';
				if (!taxaBlockOpened) taxaBlocks[y].style['background-color'] = 'hsl('+taxaBlockColor+', 50%, 50%)';
				//taxaBlocks[y].style['border-style'] = 'none';
			})
			flexPartRanks.appendChild(taxaBlocks[y]);
			if (taxaKeys[y] !== rankSubmit) taxaBlocks[y].style.display = "none";
			if (taxaKeys[y] === rankSubmit)
			{
				targetRankObject = taxaBlocks[y]; //This is the sole taxaBlock that gets shown when the GBIF find is collapsed, like all the results for a user query. I want the GBIF find expand when clicking on the taxaBlock (calling gbifResultOpenClose()), so it needs saving for the display function.
				break; // if searched in rank GENUS, it will only gather ranks until GENUS.
			}
		}
		
		let arrow = document.createElement('div');
		flexPartRanks.appendChild(arrow);
		arrow.classList.add('arrow');
		arrow.innerHTML = '⦿'; // ⪡ ⪢ ⋖ ⋗⩹⩺  ≪≫ ⦾⦿⊙ ⧀⧁ ⧏⧐ ⩹⩺⪢ ⪦⪧ ⪻⪼ ⫷⫸ ▢▣ ⋘⋙  ᗞ ᗡ ᗧ
		let displayAllRanks = false;
		arrow.addEventListener('click', ()=>
		{
			gbifResultOpenClose(true);
		});
		let targetRankObjectWasOpened = null;
		function gbifResultOpenClose(calledFromArrow)
		{
			if (displayAllRanks == false)
			{
				for (let y in taxaBlocks)
				{
					taxaBlocks[y].style.display = "block";
				}
				if (targetRankObjectDescription !== null && targetRankObjectWasOpened && calledFromArrow)
				{
					targetRankObjectDescription.classList.replace('hidden','rankDescription');
				}
				displayAllRanks = true;
				arrow.innerHTML = '⊙';
				line.style.display = 'block';
				flexPartDescription.style.display = 'flex';
				line2.style.display = 'block';
				flexPartImages.style.display = 'block';
			}
			else
			{
				for (let y in taxaBlocks)
				{
					if (taxaKeys[y] !== rankSubmit) taxaBlocks[y].style.display = "none";
				}
				if (targetRankObjectDescription !== null && calledFromArrow)
				{
					if (targetRankObjectDescription.className === 'rankDescription')
					{
						targetRankObjectDescription.classList.replace('rankDescription', 'hidden');
						targetRankObjectWasOpened = true;
					}
					else targetRankObjectWasOpened = false;
				}
				targetRankObject.style['background-color'] = 'hsl('+targetRankObjectColor+', 50%, 50%)';
				displayAllRanks = false;
				arrow.innerHTML = '⦿';
				line.style.display = 'none';
				flexPartDescription.style.display = 'none';
				line2.style.display = 'none';
				flexPartImages.style.display = 'none';
			}
			calledFromArrow = false;
		}
	}
	for (let rank in taxaKeys)
	{
		if (statsNames[taxaKeys[rank]].length > 0)
		{
			let statBlock = document.createElement('div');
			let rankClassification = document.createElement('div');
			let rankCount = document.createElement('div');
			rankClassification.innerHTML = taxaKeys[rank].toUpperCase();
			rankCount.innerHTML = statsNames[taxaKeys[rank]].length+" finds for "+querySubmit;
			rankClassification.classList.add('rankClassification');
			statBlock.classList.add('baseBlock');
			statBlock.style['background-color'] = 'grey';
			statBlock.appendChild(rankClassification);
			statBlock.appendChild(rankCount);
			resultOverview.appendChild(statBlock);
			console.log(statsNames);
		}
	}
}

function fetchEverything(y, keyId, rankDescriptionContent, flexPartImages, taxaBlockColor, arrayOfImages)
{
	let childrenLoaded = synonymsLoaded = distributionsLoaded = vernacularNamesLoaded = false;
	
	// ID fetch delivers a "proper" json object for the rank object. Most likely, the object content is identical to the content of the responded object from a user query (vernacular or scientific name). (See the first object visible in the console when doing a query, generated by the first console.log in checkResponse(), then compare it to the console message ("ID SEARCH") when clicking on the rank object, as generated by this fetch).
	// Once the rank object is found by query, all further fetches regarding this rank object are done over the ID.
	// IMPORTANT HINT: as you can see in the fetches, they all address 'species' objects, but in fact regard objects of every rank, not just species from the taxonomy rank SPECIES. To avoid confusion, I call them "rank objects" (most of the time) in my comments, to make clear that they entail GENUS, FAMILY...
	fetch('https://api.gbif.org/v1/species/'+keyId)
	.then(response => response.json())
	.then(incoming =>{console.log('ID SEARCH: '); console.log(incoming)})
	
	fetch('https://api.gbif.org/v1/species/'+keyId+'/children?limit=500')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('CHILDREN: ');
		console.log(incoming);
		if (y < 6 && incoming.results.length !== 0) // there are in fact sometimes GENEA, FAMILIES etc. that don't have children; it's the rarer case, but it exists. 
		{
			let children = document.createElement('div');
			let childCount = 0;
			for (let child in incoming.results)
			{/*
				if (y+2 < 7)
				{
					if (incoming.results[child].rank.toLowerCase() === taxaKeys[y+2]) break; // prevents moving over to grandchildren if direct children are exhausted. UPDATE: doesn't quite work, apparently the array is not always sorted from highest rank downwards.
				}*/
				// if (incoming.results[child].rank === 'UNRANKED') continue;
				if (incoming.results[child].rank.toLowerCase() === taxaKeys[y+1])
				{
					let thisChild = document.createElement('div');
					thisChild.innerHTML = "<strong>"+ incoming.results[child].rank.toUpperCase()+"</strong> "+incoming.results[child].canonicalName+"<br>";
					let theChild = incoming.results[child].key;
					thisChild.addEventListener('click', ()=> {console.log('SEARCHING FOR CHILD ID: '+theChild), search(theChild)});
					thisChild.style.cursor = 'pointer';
					thisChild.style["margin-right"] = "15px";
					children.appendChild(thisChild);
					childCount++;										
				}
			}
			let superElement = document.createElement('div');
			superElement.classList.add('baseBlock');
			superElement.style['background-color'] = `hsl(${taxaBlockColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			let elementTitle = document.createElement('div');
			elementTitle.innerHTML = '<strong>CHILDREN</strong>';
			superElement.appendChild(elementTitle);
			if (childCount > 5)
			{
				superElement.style.height = "220px";
				children.style.height = "150px";
				children.style["overflow-y"] = "auto";
			}
			superElement.appendChild(children);
			rankDescriptionContent.appendChild(superElement);
		}
		childrenLoaded = true;
	})
	
	fetch('https://api.gbif.org/v1/species/'+keyId+'/synonyms?limit=500')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('SYNONYMS: ');
		console.log(incoming)
		let allSynonyms = document.createElement('div'); 
		if (incoming.results.length !== 0)
		{
			let synonymsCount = 0;
			let checkDuplicates ="";
			for (let synonym in incoming.results)
			{
				if (checkDuplicates.search(incoming.results[synonym].canonicalName) !== -1) continue;
				let theSynonym = document.createElement('div');
				theSynonym.innerHTML = incoming.results[synonym].canonicalName;
				allSynonyms.appendChild(theSynonym);
				checkDuplicates += incoming.results[synonym].canonicalName;
				synonymsCount++;
			}
			let superElement = document.createElement('div');
			superElement.classList.add('baseBlock');
			superElement.style['background-color'] = `hsl(${taxaBlockColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			let elementTitle = document.createElement('div');
			elementTitle.innerHTML = '<strong>SYNONYMS</strong>';
			superElement.appendChild(elementTitle);
			if (synonymsCount > 5)
			{
				superElement.style.height = "220px";
				allSynonyms.style.height = "150px";
				allSynonyms.style["overflow-y"] = "auto";
			}
			superElement.appendChild(allSynonyms);
			rankDescriptionContent.appendChild(superElement);
		}
		synonymsLoaded = true;
	})
	
	fetch('https://api.gbif.org/v1/species/'+keyId+'/descriptions')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('DESCRIPTIONS: ');
		console.log(incoming);
		let allDescriptions = document.createElement('div'); 
		if (incoming.results.length !== 0)
		{
			for (let description in incoming.results)
			{
				if (incoming.results[description].description.search("There is no information available for this species.") !== -1) continue; // There may still be descriptions that start with "There is no information available for this species, but / other than...", so the comma ',' saves it from being kicked out.
				let theDescription = document.createElement('div');
				theDescription.innerHTML = "<br><strong>"+ incoming.results[description].type.toUpperCase().replace("_"," ")+"</strong><br>"+incoming.results[description].description;
				allDescriptions.appendChild(theDescription);
			}
			let superElement = document.createElement('div');
			superElement.classList.add('baseBlock');
			superElement.classList.add('resizable-content');
			superElement.style['background-color'] = `hsl(${taxaBlockColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			let elementTitle = document.createElement('div');
			elementTitle.innerHTML = '<strong>DESCRIPTIONS</strong>';
			superElement.appendChild(elementTitle);
			superElement.style.height = "300px";
			superElement.style.width = "600px";
			allDescriptions.style.height = "260px";
			allDescriptions.style["overflow-y"] = "auto";
			superElement.appendChild(allDescriptions);
			
			checkOtherElementsLoaded();
			function checkOtherElementsLoaded() // makes certain that the 'DESCRIPTION' element comes last within the description part (clicking on a GBIF rank object). Reason being that the desciption element is the only one you can resize, but the whole rankDescriptionContent element adapts in size. So making certain the it is the lower right corner of rankDescriptionContent where you can resize everything.
			// originally the description element was the only one to resize simply becuause it can have a lot of content, and someone may want to make it bigger for more comfortable reading.
			{
				if (childrenLoaded && synonymsLoaded && distributionsLoaded && vernacularNamesLoaded)
				{
					rankDescriptionContent.appendChild(superElement);
				}
				else setTimeout(checkOtherElementsLoaded, 100);
			}
			
			const resizeObserver = new ResizeObserver((entries) =>
			{
					for (const entry of entries)
					{
						allDescriptions.style.height = entry.contentRect.height-40+"px";
					}
					// console.log("resized!");
			});
			resizeObserver.observe(superElement);
			// console.log(superElement.clientWidth);
			// console.log(superElement.clientHeight);
		}
	})
	fetch('https://api.gbif.org/v1/species/'+keyId+'/distributions?limit=500')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('DISTRIBUTIONS: ');
		console.log(incoming);
		
		let allDistributions = document.createElement('div'); 
		if (incoming.results.length !== 0)
		{
			let rememberPlaces = "";
			let localitiesCounter = 0;
			for (let distribution in incoming.results)
			{	
				let theLocality = document.createElement('div');
				theLocality.style['margin-right'] = '15px';
				if (incoming.results[distribution].locality !== undefined)
				{
					if (rememberPlaces.search(incoming.results[distribution].locality) !== -1) continue;
					theLocality.innerHTML = incoming.results[distribution].locality;
					rememberPlaces += incoming.results[distribution].locality;
					localitiesCounter++;
				}							
				if (incoming.results[distribution].country !== undefined)
				{
					let theCountry = "";
					for (place in countryCodes)
					{
						if (countryCodes[place].Code === incoming.results[distribution].country.toUpperCase())
						{
							theCountry = countryCodes[place].Name;
							break;
						}
					}
					if (theCountry === "" || rememberPlaces.search(theCountry) !== -1) break;
					theLocality.innerHTML = theCountry;
					rememberPlaces += theCountry;
					localitiesCounter++;
					if (incoming.results[distribution].establishmentMeans !== undefined)
					{
						let establishment = incoming.results[distribution].establishmentMeans.toLowerCase()
						establishment = establishment.replace(establishment[0], establishment[0].toUpperCase());
						theLocality.innerHTML +=  " • <i>"+establishment+"</i>";
					}
					if (incoming.results[distribution].threatStatus !== undefined) // https://gbif.github.io/gbif-api/apidocs/src-html/org/gbif/api/vocabulary/ThreatStatus.html
					{
						if (incoming.results[distribution].threatStatus !== "NOT_EVALUATED" && incoming.results[distribution].threatStatus !== "NOT_APPLICABLE" && incoming.results[distribution].threatStatus !== "DATA_DEFICIENT")
						{
							let threat = incoming.results[distribution].threatStatus.toLowerCase()
							threat = threat.replace(threat[0], threat[0].toUpperCase());
							threat = threat.replace("_"," ");
							theLocality.innerHTML +=  " • <i>"+threat+"</i>";
						}
					}
				}
				allDistributions.appendChild(theLocality);
			}
			let superElement = document.createElement('div');
			superElement.classList.add('baseBlock');
			superElement.style['background-color'] = `hsl(${taxaBlockColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			let elementTitle = document.createElement('div');
			elementTitle.innerHTML = '<strong>LOCALITIES</strong>';
			superElement.appendChild(elementTitle);
			if (localitiesCounter > 5)
			{
				superElement.style.height = "220PX";
				allDistributions.style.height = "150px";
				allDistributions.style["overflow-y"] = "auto";
				allDistributions.style["overflow-x"] = "hidden";
			}
			superElement.appendChild(allDistributions);
			rankDescriptionContent.appendChild(superElement);	
		}
		distributionsLoaded = true;
	})
	
	fetch('https://api.gbif.org/v1/species/'+keyId+'/vernacularNames')
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('VERNACULAR NAMES');
		console.log(incoming);
		if (incoming.results.length !== 0)
		{
			nameCount = 0;
			let vernacularNames = document.createElement('div');
			let rememberNames = "";
			for (name in incoming.results)
			{ // there're often many duplicates
				if (incoming.results[name].language !== 'eng') continue;
				let tempName = incoming.results[name].vernacularName.replace("’","'");
				if (rememberNames.toLowerCase().search(tempName.toLowerCase()) !== -1) continue; // removes duplicates like "Layard's beaked whale" and "Layard’s beaked whale"
				tempName = tempName.replace("'"," "); 
				if (rememberNames.toLowerCase().search(tempName.toLowerCase()) !== -1) continue;// removes duplicates like "Layard's beaked whale" and "Layard s beaked whale"
				if (tempName.charAt(tempName.length-1)==="s") tempName = tempName.slice(0, tempName.length-1);
				if (rememberNames.toLowerCase().search(tempName.toLowerCase()) !== -1) continue; // throws out the duplicate of plurals and singulars that comes second: if 'Whale' (ORDER) is first, then 'Whales' will be dismissed.
				
				let theName = document.createElement('div');
				theName.innerHTML = incoming.results[name].vernacularName;
				theName.style["margin-right"] = "15px";
				let theRank = taxaKeys[y];
				theName.addEventListener('click',()=> {console.log("SEARCHING FOR "+theName.innerHTML+ " IN RANK CONDITION "+theRank), setTimeout(search, 3000, theName.innerHTML, theRank)});
				theName.style.cursor = 'pointer';
				vernacularNames.appendChild(theName);
				rememberNames += incoming.results[name].vernacularName;
				nameCount++;
			}
			let superElement = document.createElement('div');
			superElement.classList.add('baseBlock');
			superElement.style['background-color'] = `hsl(${taxaBlockColor}, 60%, 60%)`;
			superElement.style.cursor = 'default';
			let elementTitle = document.createElement('div');
			elementTitle.innerHTML = '<strong>VERNACULAR NAMES</strong>';
			superElement.appendChild(elementTitle);
			if (nameCount > 5)
			{
				superElement.style.height = "220px";
				vernacularNames.style.height = "150px";
				vernacularNames.style["overflow-y"] = "auto";
			}
			superElement.appendChild(vernacularNames);
			rankDescriptionContent.appendChild(superElement);
		}
		vernacularNamesLoaded = true;
	})
	
	// IMAGES
	if (y > 2) // makes certain that kingdom, phylum and class don't fetch media. The images are not of use for this app. The images for kingdom 'animalia' e.g. are a lot, and sometimes very specific (like dinosaur bones being dug out...) and to think that every time someone clicks on animalia this would show up, esp since this kingdom will be part of every animal query. It's ok with the occurrences as well, as they're images of real species. There may be photos of genera or families as well.
	{
		fetch('https://api.gbif.org/v1/species/'+keyId+'/media')
		.then(response => response.json())
		.then(incoming =>
		{
			console.log('MEDIA');
			console.log(incoming);
			if (incoming.results.length !== 0 )
			{
				const allImageSources = 
				{
					'links': [],
					'descriptions': [],
					'colors': [],
				};
				for (image in incoming.results)
				{
					let theColor = `hsl(${taxaBlockColor}, 60%, 60%)`;
					allImageSources.links.push(incoming.results[image].identifier);
					allImageSources	.colors.push(theColor);
					let description = "";
					if (incoming.results[image].description !== undefined) description = "<strong>Description</strong><br>"+ incoming.results[image].description;
					let creator = "";
					if (incoming.results[image].creator !== undefined) creator = "<br><br><strong>Creator:</strong><br>"+incoming.results[image].creator;
					allImageSources	.descriptions.push(description+creator);
				}
				displayImages(allImageSources, flexPartImages, arrayOfImages, true);
			}
		})
	}
			
	// NESTED FETCH CALL! TO MAKE CERTAIN THAT THE MEDIA IMAGES COME FIRST, AND THAT BOTH, MEDIA AND OCCURRENCES IMAGES ARE IN THE SAME OBJECT.
	fetch('https://api.gbif.org/v1/occurrence/search?speciesKey='+keyId+'&limit=500') // GBIF caps it at 300 though
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('OCCURRENCE SPECIES');
		console.log(incoming);
		if (incoming.results.length !== 0)
		{
			const allImageSources = 
			{
				'links': [],
				'descriptions': [],
				'colors': [],
			};
			for (let occurrence in incoming.results)
			{
				if (incoming.results[occurrence].media.length !== 0) // media are just an optional data within occurrences.
				{
					for (image in incoming.results[occurrence].media)
					{
						// console.log("Occurrence key: "+ incoming.results[occurrence].key);
						if (incoming.results[occurrence].media[image].format !== undefined)
						{
							//allFormats.push(incoming.results[occurrence].media[image].format);
							//allTypes.push(incoming.results[occurrence].media[image].type)
							if (incoming.results[occurrence].media[image].format.search('image') !== -1 && incoming.results[occurrence].media[image].type === "StillImage") // the first if condition accepts any format, described as "image/png", "image/jpeg"...
							{
								let oc = incoming.results[occurrence];
								console.log(oc); // have a look at the json set-up
								
								// LOCALITY
								let locality = "";
								if (oc.locality !== undefined) locality = capitalizeFirstLetters(oc.locality);
								let county = ""
								if (oc.county !== undefined) county = capitalizeFirstLetters(oc.county);
								let localityCommaCounty = "";
								if (locality !== "" && county !== "") localityCommaCounty = ", ";
								let country = "";
								if (oc.country !== undefined) country = capitalizeFirstLetters(oc.country);
								let countryComma = "";
								if ((county !== "" || locality !== "") && country !== "") countryComma = ", ";
								let continent = "";
								if (oc.continent !== undefined) continent = capitalizeFirstLetters(oc.continent);
								let continentComma = "";
								if ((locality !== "" || county !== "" || country !== "") && continent !== "") continentComma = ", ";
								let localityTitle = "";
								if (locality !== "" || county !== "" || country !== "" || continent !== "") localityTitle = "<strong>Locality: </strong>";
								
								// OCEAN AND ISLAND
								let island = "";
								if (oc.island !== undefined) island = capitalizeFirstLetters(oc.island);
								let waterBody = ""
								if (oc.waterBody !== undefined) waterBody = capitalizeFirstLetters(oc.waterBody);
								let islandCommaWaterBody = "";
								if (island !== "" && waterBody !== "") islandCommaWaterBody = ", ";
								let islandWaterBodyTitle = "";
								if (island !== "" || waterBody !== "") islandWaterBodyTitle = "<br><br><strong>Ocean</strong><br>";
								let theLocality = localityTitle+locality+localityCommaCounty+county+countryComma+country+continentComma+continent+islandWaterBodyTitle+island+islandCommaWaterBody+waterBody;
								theLocality = theLocality.replaceAll('_',' ');
								
								// LONGITUDE & LATITUDE
								let latitudeLongitude = "";
								if (oc.decimalLatitude !== undefined && oc.decimalLongitude !== undefined) latitudeLongitude = "<br><strong>Coordinates:</strong> "+oc.decimalLatitude+"° "+oc.decimalLongitude+"°";
								
								// DATE AND TIME OF RECORD
								let eventDate = "";
								if (oc.eventDate !== undefined) eventDate = oc.eventDate;
								else if (oc.georeferenceTime !== undefined) eventDate = oc.georeferenceTime; //"2023-01-02T10:01:55", both eventDate and georeference have this format.
								
								// OR:
								let day = month = year = 0;
								if (oc.day !== undefined && oc.month !== undefined && oc.year !== undefined) {day = oc.day; month = oc.month; year = oc.year}
								let eventTime = "";
								if (oc.eventTime !== undefined) eventTime = oc.eventTime; // "10:01:55"
								
								// COMBINE DATE & TIME
								let dateAndTime = "";
								if (eventDate !== "")
								{
									dateAndTime = eventDate.split('T');
									let month = months[parseInt(dateAndTime[0].substr(5,2))-1]; // -1 as first month / Jan starts at 01, and so on.
									if (dateAndTime[1] =="00:00:00") dateAndTime[1] = "";
									else dateAndTime[1] = ", "+dateAndTime[1]+" local time.";
									let updatedDate = dateAndTime[0].replace(/-[0-9]{2}-/," "+month+" ");
									dateAndTime = "<br><br><strong>Date of record:</strong> "+updatedDate+dateAndTime[1];
								}
								else if(year > 0)
								{
									if (day === 0) day = "";
									else day = " "+day
									if (month === 0) month = "";
									else month = " "+months[month-1];
									if (eventTime !== "" && eventTime !== "00:00:00")  eventTime = ", "+eventTime+" local time.";
									else eventTime = "";
									dateAndTime = "<br><br><strong>Date of record:</strong> "+year+month+day+eventTime;
									console.log(eventTime);
								}
								let recordedBy = "";
								if (oc.recordedBy !== undefined) recordedBy = "<br><strong>Recorded by:</strong> "+oc.recordedBy;
								
								let indentifiedBy = "";
								if (oc.indentifiedBy !== undefined) indentifiedBy = "<br><br><strong>Identified by </strong><br>"+ oc.indentifiedBy;
								
								// SUBJECT OBSERVATION DATA
								let sex = "";
								if (oc.sex !== undefined) sex = "<br>Sex: "+oc.sex.toLowerCase();
								let individualCount = "";
								if (oc.individualCount !== undefined) individualCount = "<br>Individual count: "+ oc.individualCount; // integer
								let isInCluster = "";
								if (oc.isInCluster !== undefined) // boolean
								{
									if (oc.isInCluster) isInCluster = "<br>Subject is part of a cluster.";
									else isInCluster = "<br>Subject is not part of a cluster.";
								}
								let conservationStatus = "";
								if (oc.iucnRedListCategory !== undefined) conservationStatus = "<br>Conservation status: <strong>"+ capitalizeFirstLetters(iucnRedList[oc.iucnRedListCategory])+"</strong>";
								let basisOfRecord = ""
								if (oc.basisOfRecord !== undefined) basisOfRecord = "<br>Basis of record: "+ capitalizeFirstLetters(oc.basisOfRecord.replace('_',' ')); // "HUMAN_OBSERVATION"
								let identificationRemarks = "";
								if (oc.identificationRemarks !== undefined) identificationRemarks = "<br>"+oc.identificationRemarks;
								let license = "";
								if (oc.license !== undefined)
								{
									if (oc.license.search('creativecommons') !== -1) license = "<br>License: Creative Commons"; // instead of a link to the license on creativecommons.org.
									else license = "<br>License: "+ oc.license;
								}
								let institutionCode = "";
								if (institutionCode !== undefined) institutionCode = "<br>Instituation code: "+oc.institutionCode;
								let subjectObservationData = sex+individualCount+isInCluster+conservationStatus+basisOfRecord+identificationRemarks+license+institutionCode;
								if (subjectObservationData.length > 0) subjectObservationData = "<br><br><strong>Subject Observation Data</strong>"+subjectObservationData; // adding title 
		
								// PUBLISHER
								let publishingCountry = "";
								if (oc.publishingCountry !== undefined)
								{
									for (countries in countryCodes)
									{
										if (publishingCountry === countryCodes[countries].Code)
										{
											publishingCountry = countryCodes[countries].Name;
											break;
										}
									}
								}
								let publisher = "";
								if (oc.media[image].publisher !== undefined) publisher = oc.media[image].publisher;
								let publisherTitle = "";
								if (publisher !== "") publisherTitle = "<br><br><strong>Publisher: </strong>";
								let publishedIn = "";
								if (publisher !== "" && publishingCountry !== "") publishedIn = ", published in "+publishingCountry;
								let publishing = publisherTitle+publisher+publishedIn;
		
								// SCIENTIFIC NAME
								let scientificName = "";
								if (oc.scientificName !== undefined) scientificName = "<br><br><strong><i>Scientific Name</i></strong><br>"+oc.scientificName;
								
								// ASSEMBLING OCCURRENCE DATA
								const descriptions = theLocality+latitudeLongitude+dateAndTime+recordedBy+indentifiedBy+subjectObservationData+publishing+scientificName;
								allImageSources.descriptions.push(descriptions);
								allImageSources.links.push(oc.media[image].identifier);
								allImageSources.colors.push("rgb(33,37,41)")
							}
						}
						else if (incoming.results[occurrence].media[image].references !== undefined) // sometimes, but rarely, there may just be a single key in the media object, e.g. called "references" or "identifier" with a media-link as the value. It can be an image, but could also be a video or other material.
						{
							for (let fileType in imageFileTypes) // making certain it's an image.
							{
								if (incoming.results[occurrence].media[image].references.search(imageFileTypes[fileType]) !== -1) 
								{
									allImageSources.links.push(incoming.results[occurrence].media[image].references);
									allImageSources.descriptions.push(undefined);
									allImageSources.colors.push("rgb(33,37,41)")
									break;
								}
							}
						}
						else if (incoming.results[occurrence].media[image].identifier !== undefined)
						{
							for (let fileType in imageFileTypes)
							{
								if (incoming.results[occurrence].media[image].identifier.search(imageFileTypes[fileType]) !== -1)
								{
									allImageSources.links.push(incoming.results[occurrence].media[image].references);
									allImageSources.descriptions.push(undefined);
									allImageSources.colors.push("rgb(33,37,41)")
									break;
								}		
							}
						}
						else console.log("UNUSUAL IMAGE SOURCE: "+incoming.results[occurrence]);
					}
				}
			}
			displayImages(allImageSources, flexPartImages, arrayOfImages);
		}
	});	
	
	/* DISMISSED FETCH CALLS
	Verbatim-get always responds with an error with the message that there's no entity. No idea how an object would look like.
	fetch('https://api.gbif.org/v1/species/'+keyId+'/verbatim') // ???
	
	For this app not of use. Also: Canonical name, authorship, year and scientific name (which is: canonical name + authorship + year) are also included in the basic query result object / ID species object.
	fetch('https://api.gbif.org/v1/species/'+keyId+'/name')

	Lists other catalogues where this rank object is present. For this app we stay in the GBIF BACKBONE TAXONOMY checklist dataset.
	fetch('https://api.gbif.org/v1/species/'+keyId+'/related?limit=500')
	
	Very most finds don't yield any other (re)combinations / basionym names.
	fetch('https://api.gbif.org/v1/species/'+keyId+'/combinations')
	
	Species profiles and references are scientific source and catalogue references for this species / rank object. For this app, which is just about browsing species for curious (non-life-scientist) people, this information is dismissable.
	fetch('https://api.gbif.org/v1/species/'+keyId+'/references')
	fetch('https://api.gbif.org/v1/species/'+keyId+'/speciesProfiles')
	
	I've not found one type specimen, I can't even tell what exactly its information purpose should be.
	fetch('https://api.gbif.org/v1/species/'+keyId+'/typeSpecimens')
	
	Parents not necessary as they're already loaded from the queried GBIF species / rank object.
	fetch('https://api.gbif.org/v1/species/'+keyId+'/parents') 
	.then(response => response.json())
	.then(incoming =>
	{
		console.log('PARENTS: ');
		console.log(incoming);
		if (incoming.length !== 0)
		{
			let parents = document.createElement('div');
			parents.classList.add('baseBlock');
			parents.style['background-color'] = `hsl(${taxaBlockColor}, 60%, 60%)`;
			parents.innerHTML = '<strong>PARENT TREE</strong><br>';
			for (let parent in incoming)
			{
				parents.innerHTML += "<strong>" + incoming[parent].rank.toUpperCase()+"</strong> "+incoming[parent].canonicalName+"<br>";
			}
			flexPartDescription.appendChild(parents);
			console.log(parents.clientHeight);
		}
	})*/
}

function displayImages(allImageSources, flexPartImages, arrayOfImages, insertImagesAtBeginning)
{
	console.log(allImageSources);
	
	let counter = 0;
	let unlock = true;
	

	
	checkWidth();
	async function checkWidth() // automatically fills the horizontal space with images when clicking on a GBIF rank object.
	{
		if (flexPartImages.scrollWidth === flexPartImages.offsetWidth && counter < allImageSources.links.length) // for as long as the content fills less than the width of the div (flexPartImages, minus padding) it appears in, scrollWidth has the width of offsetWidth (= there's no scrolling). Only if content takes more space than its div, then: scrollWidth > offsetWidth. So we assume that if offset and scroll are the same, it means that not enough images have loaded yet to fill the horizontal space.
		{
			console.log("TRYING TO AUTO-ADD IMAGE FROM OCCURRENCE");
			let promise = await addNextImage();
			if (flexPartImages.scrollWidth === flexPartImages.offsetWidth && counter < allImageSources.links.length)
			{
				checkWidth();
				console.log('MOVING ON TO NEXT IMAGE ADDRESS');
			}
		}
	}
	flexPartImages.addEventListener('scroll', () => // loads more images whenever the user scrolls to right limit.
	{
		// console.log("scrollWidth: "+flexPartImages.scrollWidth);
		// console.log("offsetWidth "+flexPartImages.offsetWidth);
		// console.log("scrollLeft: " +Math.round(flexPartImages.scrollLeft));
		
		if (unlock && flexPartImages.offsetWidth + flexPartImages.scrollLeft +1 >= flexPartImages.scrollWidth && counter < allImageSources.links.length) // unlock is a necessity because whenever you sroll to the right border (and keep pressing against it), this listener fires a addNextImage() call, which stacks up to many concurrent calls within split seconds. Await wouldn't work as it would still be mutliple addNextImage() calls (all awaiting the promise return). ... the +1 pixel is a necessity as sometimes the numbers don't perfectly add up.
		{
			unlock = false;
			addNextImage();
		}
	});
	
	async function addNextImage(callFromFullWindowMode)
	{
		if (callFromFullWindowMode) fullWindowNavigationStates('atEndDownloadMore');
		while(true)
		{
			if (await getImage(callFromFullWindowMode)) break;
			console.log("RETURN IS FALSE. TRYING NEXT ONE.");
		}
		if (callFromFullWindowMode && !downloadedAllImages)			fullWindowNavigationStates();
		else fullWindowNavigationStates('atEndNoMoreDownloads');
		
		return true;
	}
	
	async function getImage(callFromFullWindowMode)
	{
		let gotImage = true;
		let moment = new Date().getTime();
		
		console.log("FETCHING IMAGE");
		flexPartImages.appendChild(svg);
		svg.animate(fadeIn, timing);
		const theImage = await downloadImage(allImageSources.links[counter]);
		console.log("FETCHING DONE! After "+ (new Date().getTime() - moment)+"ms");
		
		// console.log(Object.prototype.toString.call(theImage));
		// console.log(theImage instanceof Error)
		
		if (theImage !== false)
		{
			svg.animate(fadeOut, timing);
			setTimeout( ()=>
			{
				//flexPartImages.removeChild(svg);
				// image gets cloned to an array for full-window display, to avoid pointer to same image object. Image in flexPartImages and on full-window display demand different image attributes.
				const clonedImage = document.createElement('IMG');
				clonedImage.src = theImage.src;
				theImage.style.opacity = 0;
				clonedImage.style.opacity = 0;
				if (callFromFullWindowMode) fullWindowImagesArray.push(clonedImage);

				if (insertImagesAtBeginning) 
				{
					arrayOfImages.unshift(clonedImage);
					flexPartImages.prepend(theImage);
				}
				else
				{
					arrayOfImages.push(clonedImage);
					flexPartImages.appendChild(theImage);
				}
				theImage.classList.add('resultImage');
				theImage.style['border-color'] = allImageSources.colors[counter];
				theImage.style['outline-color'] = allImageSources.colors[counter];
				renderImageText(theImage, allImageSources.descriptions[counter],allImageSources.colors[counter],flexPartImages);
				clickOnImage(theImage, flexPartImages, arrayOfImages, addNextImage);
				theImage.animate(fadeIn, timing);
				clonedImage.animate(fadeIn, timing);
			},fadeTime);
		}
		else
		{
			console.log('NO IMAGE RETRIEVED');
			gotImage = false;
		}
		counter++;
		
		/*
		// TEST 1
		theTest = document.createElement('div');
		//theTest.style['background-color'] = 'indigo';
		theTest.classList.add('resultImage');
		theTest.style.width = '500px';
		theTest.style['border-color'] = allImageSources.colors[counter];
		theTest.style['outline-color'] = allImageSources.colors[counter];
		theTest.appendChild(loadAni);
		// it's impossible to add a div to horizontal flex-wrap element, because it will create a new row for every different element type. So you have three images in a row, but if then a div is added it would create a second row. If the next element would also be a div, it would expand the row. If it was an image again, it would create a third row, and so on.
			
		// TEST 2
		const loadTest = document.createElement('img');
		loadTest.classList.add('loader2');
		flexPartImages.appendChild(loadTest);
		loadTest.animate(loadRotate, loadTiming);
		if (counter === 5) setTimeout(()=>{loadTest.remove();},3000);
		if (counter === 5) setTimeout(()=>{flexPartImages.appendChild(loadTest);},6000);
		// WORKS FINE*/
		
		if (counter > allImageSources.links.length-1)
		{
			console.log("ALL IMAGES URLS OF ALL OCCURRENCES FETCHED!");
			gotImage = true;
			downloadedAllImages = true;
		}
		else
		{
			unlock = true;
			downloadedAllImages = false;
		}
		return gotImage;
	}
	
	async function downloadImage(address)
	{
		const image = document.createElement('IMG');
		const thePromise = new Promise(resolve =>
		{
			image.src = address;
			image.onload = resolve;
			image.onerror = resolve; // when the image addresses is a 404. If it was only image.onload, it would just wait forever; "empty" images are handled in the if statement after the fulfilled promise. The purpose of this async func is to make getImage() wait for fully loaded images.
		})
		await thePromise;
		if (image.naturalWidth === 0) return false;
		else return image;
	}

	/* Originally I had all the image addresses from the occurrences put through this function. Eventually it occurred to me that if I have already the addresses, I don't need to fetch for anything anymore, I can just download it. This function worked well in catching errors (which upper I resolved with image.onerror). Also it caused a lot of CORS-blocks as many image hosters and other sites didn't have CORS defined (at least 50% got blocked). In the end, it was a silly thing to do to have image addresses put through fetch calls.
	async function downloadImage(address)
	{
		let theReturn;
		await fetch(address, // finally found a proper example of how to set headers: https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch
		// Some of the servers hosting the images simply do not have CORS enabled, and thus will send back an error. The console message will be:
		// Access to fetch at 'https://inaturalist-open-data.s3.amazonaws.com/photos/209207215/original.jpeg' from origin 'http://127.0.0.1:8000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.
		// There's nothing I can do: https://stackoverflow.com/questions/36878255/allow-access-control-allow-origin-header-using-html5-fetch-api
		{
			method: "GET",
		    mode: "cors",
		    cache: "default",
		    credentials: "same-origin",
		    headers: {
		      "Content-Type": "application/json",
		    },
		    redirect: "follow",
		    referrerPolicy: "no-referrer",
		})								
		.then(incoming => 
		{
			// console.log("Status code: " +incoming.status);
			if (incoming.status >= 200 && incoming.status < 400)
			{
				//console.log(incoming);
				console.log("IMAGE FETCHED!");
				theReturn = document.createElement('IMG');
				theReturn.src = incoming.url;
			}
			else theReturn.prototype = Error.prototype;
		})
		.catch(error =>
		{
			console.log(error);
			theReturn = error;
		})
		return theReturn;
	}*/
}

function renderImageText(theImage, theText, frameColor, flexPartImages)
{
	let renderedText = document.createElement('div');
	renderedText.classList.add('imageDescription');
	renderedText.style['background-color'] = frameColor;
	renderedText.innerHTML = theText;
	renderedText.style.position = 'absolute';
	body.appendChild(renderedText);
	
	theImage.onmousemove = (mouse)=>
	{
		// console.log("mouse position:", mouse.clientX, mouse.clientY);
		renderedText.style.top = mouse.clientY+window.scrollY-renderedText.clientHeight/2+10+'px'; // the '10' moves it the description center to the center of the mouse height-wise.
		renderedText.style.left = mouse.clientX+50+'px';
	};
	theImage.addEventListener('mouseover',()=>
	{
		renderedText.style.display = 'block';
	});
	theImage.addEventListener('mouseout',()=>
	{
		renderedText.style.display = 'none';
	});
	
	// credits: katspaugh. https://stackoverflow.com/questions/6575159/get-image-dimensions-with-javascript-before-image-has-fully-loaded
	let getRes = setInterval(function ()
	{
	    if (theImage.naturalWidth)
	    {
	        clearInterval(getRes);
	        renderedText.innerHTML += "<br><br><strong>Image</strong><br>Dimensions: "+theImage.naturalWidth+"px "+theImage.naturalHeight+"px<br>Aspect Ratio: "+(theImage.naturalWidth/theImage.naturalHeight).toFixed(2);
	    }
	}, 10);
	
	/* a function that renders at 60Hz. It works, but the upper mouse events are convenient as well.
	Use mouseout and mouseover to switch isHovering boolean
	function displayImageInformation()
	{
		// do your thing
		if(isHovering) setTimeout(displayImageInformation, 16.7);
		// OR
		setInterval(()=>
		{
			// RENDERING
			if (!isHovering) return;
		},16.7)
	} 
	*/
}

function clickOnImage(theImage, flexPartImages, arrayOfImages, addNextImage)
{
	functionAddNextImage = addNextImage;
	theImage.addEventListener('mouseover',()=>
	{
		theImage.style['cursor'] = 'cell';
	});
	theImage.addEventListener('mouseout',()=>
	{
		theImage.style['cursor'] = 'auto';
	})
	theImage.addEventListener('click',()=>
	{
		fullWindow.style.top = 0+window.scrollY+'px';
		fullWindow.style.width = '100%';
		fullWindow.style.height = '100%';
		fullWindow.style.display = 'block';
		fullWindow.style['z-index'] = 1;
		fullWindowImage.style['z-index'] = 2;
		arrowLeft.style['z-index'] = 3;
		arrowRight.style['z-index'] = 3;
		loadAni.style['z-index'] = 4;
		body.style.overflow = 'hidden';
		
		if (fullWindowImagesArray.length > 0)
		{
			if (fullWindowImagesArray[0].src.search(arrayOfImages[0].src) === -1) // if this is true, the global variable fullWindowImagesArray is being overwritten by the images of a different GBIF result.
			{
				console.log("CREATE NEW IMAGE ARRAY");
				fullWindowImagesArray = [];
				downloadedAllImages = false;
			}
		}
		if (arrayOfImages.length > fullWindowImagesArray.length)
		{
			for (let x = fullWindowImagesArray.length; x < arrayOfImages.length; x++)
			{
				fullWindowImagesArray.push(arrayOfImages[x]);
			}
		}
		
		
		/*
		//console.log(flexPartImages.children);
		if (fullWindowImagesArrayID.search(theImage.src) === -1) // first time accessing an image on a GBIF result. Array.prototype.indexOf.call(fullWindowImagesArray, theImage) wouldn't work, as this array is filled with clones of 'theImage'. So I created this string that simply has all the image addresses, guaranteeing that it is unique since images addresses are unique and since occurrences can only be associated with one GBIF species / rank object.
		{
			fullWindowImagesArray = [];
			fullWindowImagesArrayID = "";
			for (image in flexPartImages.children)
			{
				if (flexPartImages.children[image].tagName !== 'IMG') break; // there're in fact HTMLCollection prototype data (element.children is an HTMLCollection) put into a couple of additional array slots to fullWindowImagesArray, if it wasn't for this check.
				// console.log(flexPartImages.children[image]);
				const clonedImage = document.createElement('IMG');
				clonedImage.src = flexPartImages.children[image].src;
				fullWindowImagesArrayID += clonedImage.src;
				// clones are necessary to avoid multiple pointers to same element. Also: taking just the elements from flexPartImages and change their display attributes for full-window display would make it necessary to change them back for flexPartImages display.
				// It is possible to just create an array from an HTMLCollection using Array.from(), but the array elements would be pointing to the same images.
				fullWindowImagesArray.push(clonedImage);
			}
			console.log("CREATE NEW IMAGE ARRAY");
		}
		else console.log("CALLING SAME IMAGE ARRAY");
		*/
		thisImageIndex = Array.prototype.indexOf.call(flexPartImages.children, theImage);
		displayImageFullWindow();
	});
}

function displayImageFullWindow()
{	
	console.log('INDEX: '+thisImageIndex);
	console.log(fullWindowImagesArray);
	
	fullWindowImage.src = fullWindowImagesArray[thisImageIndex].src;
	fullWindowImage.onload = () =>
	{
		const windowAspectRatio = fullWindow.clientWidth / fullWindow.clientHeight;
		const imageAspectRatio = fullWindowImage.naturalWidth / fullWindowImage.naturalHeight;
		
		console.log("Image Resolution: "+fullWindowImage.naturalWidth+" * "+fullWindowImage.naturalHeight);
		console.log("Image Aspect Ratio: "+imageAspectRatio);
		console.log("Window Resolution: "+fullWindow.clientWidth+" * "+fullWindow.clientHeight);
		console.log("Window Aspect Ratio: "+windowAspectRatio);
		
		if (fullWindowImage.naturalWidth < fullWindow.clientWidth && fullWindowImage.naturalHeight < fullWindow.clientHeight)
		{
			fullWindowImage.style.width = fullWindowImage.naturalWidth+'px';
			fullWindowImage.style.height = fullWindowImage.naturalHeight+'px';
		}
		else if (imageAspectRatio >= windowAspectRatio)
		{
			fullWindowImage.style.width = '100%';
			fullWindowImage.style.height = fullWindow.clientWidth/imageAspectRatio+'px';
			console.log("RENDERED Image Aspect Ratio: "+fullWindow.clientWidth/(fullWindow.clientWidth/imageAspectRatio));
		}
		else
		{
			fullWindowImage.style.height = '100%';
			fullWindowImage.style.width = fullWindow.clientHeight*imageAspectRatio+'px';
			console.log("RENDERED Image Aspect Ratio: "+(fullWindow.clientHeight*imageAspectRatio)/fullWindow.clientHeight);
		}
		// fullWindowImage.style['aspect-ratio'] = aspectRatio; // doesn't work really (maybe only with div containers?). Also it's not necessary: If one side is set to 100%, the other side keeps the aspect ratio by default;
		fullWindowImage.style.position = 'absolute';
		//fullWindowImage.style.margin = 'auto';
		fullWindowImage.style.left = '50%';
		fullWindowImage.style.top = '50%';
		fullWindowImage.style.transform = 'translate(-50%,-50%)';
		
		if (downloadedAllImages && thisImageIndex >= fullWindowImagesArray.length-1)
		{
			fullWindowNavigationStates('atEndNoMoreDownloads');
		}
	};
}

// I actually know regex, but I was lazy. Grabbed it from Gonzalo Pincheira Arancibia's solution: https://stackoverflow.com/questions/42755664/capitalize-first-letter-of-each-word-in-js
function capitalizeFirstLetters(str)
{
	return str.toLowerCase().replace(/^\w|\s\w/g, function (letter)
	{
	  return letter.toUpperCase();
	})
}
// Kamil Kiełczewski's solution: https://stackoverflow.com/questions/36721830/convert-hsl-to-rgb-and-hex/54014428#54014428
function hsl2rgb(h,s,l)
{
  let a= s*Math.min(l,1-l);
  let f= (n,k=(n+h/30)%12) => l - a*Math.max(Math.min(k-3,9-k,1),-1);
  return [f(0),f(8),f(4)];
}

function rgb2hsl(r,g,b) {
  let v=Math.max(r,g,b), c=v-Math.min(r,g,b), f=(1-Math.abs(v+v-c-1)); 
  let h= c && ((v==r) ? (g-b)/c : ((v==g) ? 2+(b-r)/c : 4+(r-g)/c)); 
  return [60*(h<0?h+6:h), f ? c/f : 0, (v+v-c)/2];
}

function getRndInteger(min, max) {
  return Math.floor(Math.random() * (max - min + 1) ) + min;
}

const iucnRedList = {'NE': 'Not evaluated','DD': 'Data deficient','LC': 'Least concern','NT': 'Near threatened','VU': 'Vulnerable','EN': 'Endangered','CR': 'Critically endangered','EW': 'Extinct in the wild','EX': 'Extinct'};

const months = ["January","February","March","April","May","June","July","August","September","October","November","December"];

const imageFileTypes = [".jpg",".jpeg",".jpe",".jif",".jfif",".jfi",".webp",".gif",".png",".apgn",".bmp",".dib"];

const countryCodes = [{"Code": "AF", "Name": "Afghanistan"},{"Code": "AX", "Name": "\u00c5land Islands"},{"Code": "AL", "Name": "Albania"},{"Code": "DZ", "Name": "Algeria"},{"Code": "AS", "Name": "American Samoa"},{"Code": "AD", "Name": "Andorra"},{"Code": "AO", "Name": "Angola"},{"Code": "AI", "Name": "Anguilla"},{"Code": "AQ", "Name": "Antarctica"},{"Code": "AG", "Name": "Antigua and Barbuda"},{"Code": "AR", "Name": "Argentina"},{"Code": "AM", "Name": "Armenia"},{"Code": "AW", "Name": "Aruba"},{"Code": "AU", "Name": "Australia"},{"Code": "AT", "Name": "Austria"},{"Code": "AZ", "Name": "Azerbaijan"},{"Code": "BS", "Name": "Bahamas"},{"Code": "BH", "Name": "Bahrain"},{"Code": "BD", "Name": "Bangladesh"},{"Code": "BB", "Name": "Barbados"},{"Code": "BY", "Name": "Belarus"},{"Code": "BE", "Name": "Belgium"},{"Code": "BZ", "Name": "Belize"},{"Code": "BJ", "Name": "Benin"},{"Code": "BM", "Name": "Bermuda"},{"Code": "BT", "Name": "Bhutan"},{"Code": "BO", "Name": "Bolivia, Plurinational State of"},{"Code": "BQ", "Name": "Bonaire, Sint Eustatius and Saba"},{"Code": "BA", "Name": "Bosnia and Herzegovina"},{"Code": "BW", "Name": "Botswana"},{"Code": "BV", "Name": "Bouvet Island"},{"Code": "BR", "Name": "Brazil"},{"Code": "IO", "Name": "British Indian Ocean Territory"},{"Code": "BN", "Name": "Brunei Darussalam"},{"Code": "BG", "Name": "Bulgaria"},{"Code": "BF", "Name": "Burkina Faso"},{"Code": "BI", "Name": "Burundi"},{"Code": "KH", "Name": "Cambodia"},{"Code": "CM", "Name": "Cameroon"},{"Code": "CA", "Name": "Canada"},{"Code": "CV", "Name": "Cape Verde"},{"Code": "KY", "Name": "Cayman Islands"},{"Code": "CF", "Name": "Central African Republic"},{"Code": "TD", "Name": "Chad"},{"Code": "CL", "Name": "Chile"},{"Code": "CN", "Name": "China"},{"Code": "CX", "Name": "Christmas Island"},{"Code": "CC", "Name": "Cocos (Keeling) Islands"},{"Code": "CO", "Name": "Colombia"},{"Code": "KM", "Name": "Comoros"},{"Code": "CG", "Name": "Congo"},{"Code": "CD", "Name": "Congo, the Democratic Republic of the"},{"Code": "CK", "Name": "Cook Islands"},{"Code": "CR", "Name": "Costa Rica"},{"Code": "CI", "Name": "C\u00f4te d'Ivoire"},{"Code": "HR", "Name": "Croatia"},{"Code": "CU", "Name": "Cuba"},{"Code": "CW", "Name": "Cura\u00e7ao"},{"Code": "CY", "Name": "Cyprus"},{"Code": "CZ", "Name": "Czech Republic"},{"Code": "DK", "Name": "Denmark"},{"Code": "DJ", "Name": "Djibouti"},{"Code": "DM", "Name": "Dominica"},{"Code": "DO", "Name": "Dominican Republic"},{"Code": "EC", "Name": "Ecuador"},{"Code": "EG", "Name": "Egypt"},{"Code": "SV", "Name": "El Salvador"},{"Code": "GQ", "Name": "Equatorial Guinea"},{"Code": "ER", "Name": "Eritrea"},{"Code": "EE", "Name": "Estonia"},{"Code": "ET", "Name": "Ethiopia"},{"Code": "FK", "Name": "Falkland Islands (Malvinas)"},{"Code": "FO", "Name": "Faroe Islands"},{"Code": "FJ", "Name": "Fiji"},{"Code": "FI", "Name": "Finland"},{"Code": "FR", "Name": "France"},{"Code": "GF", "Name": "French Guiana"},{"Code": "PF", "Name": "French Polynesia"},{"Code": "TF", "Name": "French Southern Territories"},{"Code": "GA", "Name": "Gabon"},{"Code": "GM", "Name": "Gambia"},{"Code": "GE", "Name": "Georgia"},{"Code": "DE", "Name": "Germany"},{"Code": "GH", "Name": "Ghana"},{"Code": "GI", "Name": "Gibraltar"},{"Code": "GR", "Name": "Greece"},{"Code": "GL", "Name": "Greenland"},{"Code": "GD", "Name": "Grenada"},{"Code": "GP", "Name": "Guadeloupe"},{"Code": "GU", "Name": "Guam"},{"Code": "GT", "Name": "Guatemala"},{"Code": "GG", "Name": "Guernsey"},{"Code": "GN", "Name": "Guinea"},{"Code": "GW", "Name": "Guinea-Bissau"},{"Code": "GY", "Name": "Guyana"},{"Code": "HT", "Name": "Haiti"},{"Code": "HM", "Name": "Heard Island and McDonald Islands"},{"Code": "VA", "Name": "Holy See (Vatican City State)"},{"Code": "HN", "Name": "Honduras"},{"Code": "HK", "Name": "Hong Kong"},{"Code": "HU", "Name": "Hungary"},{"Code": "IS", "Name": "Iceland"},{"Code": "IN", "Name": "India"},{"Code": "ID", "Name": "Indonesia"},{"Code": "IR", "Name": "Iran, Islamic Republic of"},{"Code": "IQ", "Name": "Iraq"},{"Code": "IE", "Name": "Ireland"},{"Code": "IM", "Name": "Isle of Man"},{"Code": "IL", "Name": "Israel"},{"Code": "IT", "Name": "Italy"},{"Code": "JM", "Name": "Jamaica"},{"Code": "JP", "Name": "Japan"},{"Code": "JE", "Name": "Jersey"},{"Code": "JO", "Name": "Jordan"},{"Code": "KZ", "Name": "Kazakhstan"},{"Code": "KE", "Name": "Kenya"},{"Code": "KI", "Name": "Kiribati"},{"Code": "KP", "Name": "Korea, Democratic People's Republic of"},{"Code": "KR", "Name": "Korea, Republic of"},{"Code": "KW", "Name": "Kuwait"},{"Code": "KG", "Name": "Kyrgyzstan"},{"Code": "LA", "Name": "Lao People's Democratic Republic"},{"Code": "LV", "Name": "Latvia"},{"Code": "LB", "Name": "Lebanon"},{"Code": "LS", "Name": "Lesotho"},{"Code": "LR", "Name": "Liberia"},{"Code": "LY", "Name": "Libya"},{"Code": "LI", "Name": "Liechtenstein"},{"Code": "LT", "Name": "Lithuania"},{"Code": "LU", "Name": "Luxembourg"},{"Code": "MO", "Name": "Macao"},{"Code": "MK", "Name": "Macedonia, the Former Yugoslav Republic of"},{"Code": "MG", "Name": "Madagascar"},{"Code": "MW", "Name": "Malawi"},{"Code": "MY", "Name": "Malaysia"},{"Code": "MV", "Name": "Maldives"},{"Code": "ML", "Name": "Mali"},{"Code": "MT", "Name": "Malta"},{"Code": "MH", "Name": "Marshall Islands"},{"Code": "MQ", "Name": "Martinique"},{"Code": "MR", "Name": "Mauritania"},{"Code": "MU", "Name": "Mauritius"},{"Code": "YT", "Name": "Mayotte"},{"Code": "MX", "Name": "Mexico"},{"Code": "FM", "Name": "Micronesia, Federated States of"},{"Code": "MD", "Name": "Moldova, Republic of"},{"Code": "MC", "Name": "Monaco"},{"Code": "MN", "Name": "Mongolia"},{"Code": "ME", "Name": "Montenegro"},{"Code": "MS", "Name": "Montserrat"},{"Code": "MA", "Name": "Morocco"},{"Code": "MZ", "Name": "Mozambique"},{"Code": "MM", "Name": "Myanmar"},{"Code": "NA", "Name": "Namibia"},{"Code": "NR", "Name": "Nauru"},{"Code": "NP", "Name": "Nepal"},{"Code": "NL", "Name": "Netherlands"},{"Code": "NC", "Name": "New Caledonia"},{"Code": "NZ", "Name": "New Zealand"},{"Code": "NI", "Name": "Nicaragua"},{"Code": "NE", "Name": "Niger"},{"Code": "NG", "Name": "Nigeria"},{"Code": "NU", "Name": "Niue"},{"Code": "NF", "Name": "Norfolk Island"},{"Code": "MP", "Name": "Northern Mariana Islands"},{"Code": "NO", "Name": "Norway"},{"Code": "OM", "Name": "Oman"},{"Code": "PK", "Name": "Pakistan"},{"Code": "PW", "Name": "Palau"},{"Code": "PS", "Name": "Palestine, State of"},{"Code": "PA", "Name": "Panama"},{"Code": "PG", "Name": "Papua New Guinea"},{"Code": "PY", "Name": "Paraguay"},{"Code": "PE", "Name": "Peru"},{"Code": "PH", "Name": "Philippines"},{"Code": "PN", "Name": "Pitcairn"},{"Code": "PL", "Name": "Poland"},{"Code": "PT", "Name": "Portugal"},{"Code": "PR", "Name": "Puerto Rico"},{"Code": "QA", "Name": "Qatar"},{"Code": "RE", "Name": "R\u00e9union"},{"Code": "RO", "Name": "Romania"},{"Code": "RU", "Name": "Russian Federation"},{"Code": "RW", "Name": "Rwanda"},{"Code": "BL", "Name": "Saint Barth\u00e9lemy"},{"Code": "SH", "Name": "Saint Helena, Ascension and Tristan da Cunha"},{"Code": "KN", "Name": "Saint Kitts and Nevis"},{"Code": "LC", "Name": "Saint Lucia"},{"Code": "MF", "Name": "Saint Martin (French part)"},{"Code": "PM", "Name": "Saint Pierre and Miquelon"},{"Code": "VC", "Name": "Saint Vincent and the Grenadines"},{"Code": "WS", "Name": "Samoa"},{"Code": "SM", "Name": "San Marino"},{"Code": "ST", "Name": "Sao Tome and Principe"},{"Code": "SA", "Name": "Saudi Arabia"},{"Code": "SN", "Name": "Senegal"},{"Code": "RS", "Name": "Serbia"},{"Code": "SC", "Name": "Seychelles"},{"Code": "SL", "Name": "Sierra Leone"},{"Code": "SG", "Name": "Singapore"},{"Code": "SX", "Name": "Sint Maarten (Dutch part)"},{"Code": "SK", "Name": "Slovakia"},{"Code": "SI", "Name": "Slovenia"},{"Code": "SB", "Name": "Solomon Islands"},{"Code": "SO", "Name": "Somalia"},{"Code": "ZA", "Name": "South Africa"},{"Code": "GS", "Name": "South Georgia and the South Sandwich Islands"},{"Code": "SS", "Name": "South Sudan"},{"Code": "ES", "Name": "Spain"},{"Code": "LK", "Name": "Sri Lanka"},{"Code": "SD", "Name": "Sudan"},{"Code": "SR", "Name": "Suriname"},{"Code": "SJ", "Name": "Svalbard and Jan Mayen"},{"Code": "SZ", "Name": "Swaziland"},{"Code": "SE", "Name": "Sweden"},{"Code": "CH", "Name": "Switzerland"},{"Code": "SY", "Name": "Syrian Arab Republic"},{"Code": "TW", "Name": "Taiwan, Province of China"},{"Code": "TJ", "Name": "Tajikistan"},{"Code": "TZ", "Name": "Tanzania, United Republic of"},{"Code": "TH", "Name": "Thailand"},{"Code": "TL", "Name": "Timor-Leste"},{"Code": "TG", "Name": "Togo"},{"Code": "TK", "Name": "Tokelau"},{"Code": "TO", "Name": "Tonga"},{"Code": "TT", "Name": "Trinidad and Tobago"},{"Code": "TN", "Name": "Tunisia"},{"Code": "TR", "Name": "Turkey"},{"Code": "TM", "Name": "Turkmenistan"},{"Code": "TC", "Name": "Turks and Caicos Islands"},{"Code": "TV", "Name": "Tuvalu"},{"Code": "UG", "Name": "Uganda"},{"Code": "UA", "Name": "Ukraine"},{"Code": "AE", "Name": "United Arab Emirates"},{"Code": "GB", "Name": "United Kingdom"},{"Code": "US", "Name": "United States"},{"Code": "UM", "Name": "United States Minor Outlying Islands"},{"Code": "UY", "Name": "Uruguay"},{"Code": "UZ", "Name": "Uzbekistan"},{"Code": "VU", "Name": "Vanuatu"},{"Code": "VE", "Name": "Venezuela, Bolivarian Republic of"},{"Code": "VN", "Name": "Viet Nam"},{"Code": "VG", "Name": "Virgin Islands, British"},{"Code": "VI", "Name": "Virgin Islands, U.S."},{"Code": "WF", "Name": "Wallis and Futuna"},{"Code": "EH", "Name": "Western Sahara"},{"Code": "YE", "Name": "Yemen"},{"Code": "ZM", "Name": "Zambia"},{"Code": "ZW", "Name": "Zimbabwe"}]


</script>
{% endblock %}